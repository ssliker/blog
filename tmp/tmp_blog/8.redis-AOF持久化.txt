1.关于AOF持久化：
    1.AOF持久化方式是Redis提供的一种将数据修改记录追加至磁盘文件的持久化方式；
    2.AOF可以单独使用，也可以和RDB的方式配合使用；
    3.AOF以独立日志的形式，记录每次redis执行的写操作，在恢复时安装记录顺序再次执行命令达到恢复的目的；
2.AOF触发方式：
    1.AOF只要在配置文件中开启即可，开启之后每次执行更新操作都会触发；

3.AOF持久化相关配置项：
    1：是否使用AOF的方式持久化数据：
        appendonly no ：：默认是no，即不开启AOF的方式持久化数据；设置为yes即可开启；
    2：使用AOF方式持久化数据时使用的策略：
        appendfsync everysec 
            1.redis在记录写操作命令时并不会直接写入磁盘文件，而是先写入缓存中，然后按照配置文件中的配置方式刷盘；
            2：有三种策略可选，如下：no,always，everysec；
            2：no：指通过操作系统来保证缓存中的数据同步到磁盘，速度最快但是可靠性最差，有可能会丢失较多的数据；
               always：指每更新一次数据就将更新命令写入aof文件，可靠性最高，使用该方式会频繁产生系统调用来将更新命令写入aof文件，会给Redis带来较大压力，导致响应速度变慢；
               everysec：指每秒执行一次持久化，可靠性较高，服务端压力适中，虽然每秒刷盘一次，但是如果发生故障将最差可能丢失2s的数据；推荐设置为该值；
    3：以AOF方式持久化时aof文件的名称：
        appendfilename appendonly.aof   ：AOF方式持久化数据时的文件名；

4.AOF持久化方式：
    1.如果在配置文件中配置appendonly为yes，那么在redis服务启动时就会以写的方式打开aof文件，并将aof文件的句柄赋值给server.aof_fd；如果在启动过程中打开aof文件失败那么服务也将启动失败；
    2.redis运行过程中如果收到写命令，那么会在call函数中执行完相关命令之后，调用propagate()函数，而在propagate()函数中会调用feedAppendOnlyFile()函数来执行AOF流程；feedAppendOnlyFile()完成两个事情：
        1.将命令格式化；
            1.先创建一个空的sds字符串，用来存储将要持久化的命令；
            2.检测当前写入aof_buf的数据库id是否是当前命令所操作的数据库id，如果不是需要在命令前面先加上SELECT db命令，保证在恢复数据时能够将数据恢复至正确的数据库；
            3.转换命令中的有效期格式：
                1.如果当前命令仅为设置过期时间，则将相对时间转换为绝对时间；
                2.如果当前命令在设置键值的同时设置有效期，则先拆分命令为设置键值命令和设置有效期命令，然后将有效期时间转换为绝对时间；
            4.对转换之后的命令格式化成指定格式的字符串，并追加至第一步执行完成后的字符串后(如果有的话)；
        2.将格式化之后的命令追加至aof_buf中；
            将第一步格式化之后的字符串添加至aof_buf缓冲区中；如果此时正在进行aof_rewrite操作，那么也会将该命令追加至aof_rewrite_buf中；
    3.同步磁盘文件：
        由于aof持久化方式直接操作文件本身，属于重量级操作，如果每次直接将命令追加至文件中，效率会比较低；因此redis会先将待追加命令写入缓存中，然后按照配置文件中配置的appendfsync everysec来择机将缓存刷入磁盘；具体流程如下：
        1.为了防止在数据恢复之后数据出现不一致，因此在回复客户端修改结果之前需要先将aof_buf按照策略刷盘持久化，而回复客户端之前需要先在事件循环中进入休眠，一旦进入休眠，那么客户端的写事件就会就绪，就需要向客户端回复响应；因此aof_buf刷盘的唯一机会就在进入休眠之前，而redis会在进入休眠之前调用beforeSleep()函数完成休眠之前的善后工作，因此redis会在该函数中调用flushAppendOnlyFile(0)函数来完成刷盘操作；
        2.flushAppendOnlyFile(0)函数接收一个参数，该参数(force)表示是否强制执行刷盘操作，之所以要有该参数是因为，在输盘策略配置为1时，在reids后台可能会有子线程正在执行fsync操作，如果有线程正在执行fsync操作时那么write可能会发生阻塞，因此需要将本次刷盘的flush操作延迟执行；如果force参数设置为1，那么redis将会无视后台的fsync，直接执行写入操作；
        3.flushAppendOnlyFile(0)将按照以下流程执行持久化：
            1.检测aof_buf中是否有待持久化数据，如果没有则直接返回；
            2.如果同步策略是每秒执行一次，那么会先检测当前后台是否有线程正在执行之前的aof操作；因为有可能aof操作时间较久，导致上次的aof操作还未完成；
            3.如果同步策略是每秒执行一次，并且不是强制执行，同时还有后台线程正在执行之前的aof操作；则继续判断在本次aof刷盘之前还有更早的延迟操作；
                1.如果没有，则表示当前aof操作之前没有等到被刷盘的操作，然后将当前时间保存下来作为当前操作的延迟开始时间，直接返回；
                2.如果在当前aof操作之前已经有上一次的aof操作还未执行而且正在等待执行，并且等待时间没有超过2s，那么直接返回，不执行write，将本次刷盘操作和正在等待延迟刷盘操作合并执行；
                3.如果在本次aof操作之前，已有等待执行刷盘的aof操作并且等待时间超过2s；则直接执行write操作刷盘；并将延迟时间恢复为0；
                4.检测写入是否出错，即写入文件的字节数如果不等于缓存的字节数则发生异常：
                    1.如果写入策略为每次执行写操作之后都需要写入文件：那么直接终止程序；
                    2.如果写入策略为每秒一次：
                        1.如果写入错误，则直接记录错误日志，并返回；
                        2.如果只写入了部分数据，则将本次给文件中追加的内容截断，删掉已经追加的内容，然后返回；
                        3.如果无法截断已经写入的aof文件，则将aof_buf进行截断，只留未写入文件的部分缓存；
                5.如果写入未出错，则更新写入状态以及aof文件大小；检测是否需要重用当前缓存；如果当前aof_buf小于4k，则直接将缓存内容清空，然后继续重用缓存；否则释放掉这个大内存，然后重新申请一个更小的内存空间；
            4.写入成功之后需要调用fsync刷新系统缓冲区，如果正在执行BGSAVE或者正在执行BGREWRITE，那么不执行本次fsync操作；如果持久化策略为always，那么调用fsync刷新系统缓冲区，如果刷新策略是EVERYSEC，并且当前时间大于上次执行同步的时间，而且当前没有正在执行同步的线程，那么在后台开一个线程执行同步；

5.AOF重写机制：
    1.重写原因：
        由于aof是追加的方式向一个独立的文件中写入操作命令，如果redis在运行比较久之后可能该aof文件体积会比较大，为了解决这个问题，redis引入了重写机制来压缩文件的体积； 
    
    2.重写方式：
        1.进程内已经超时的数据不在写入文件；
        2.无效命令不再写入文件；
        3.同一个key的多条写命令合并成一个；
    
    3.触发机制：
        1.手动触发：手动向服务端发送BGREWRITEAOF命令；
        2.自动触发：根据redis.conf配置IDE两个参数确定触发时机：
            1.auto-aof-rewrite-percentage 100：当前AOF文件的大小和上一次重写后AOF文件的大小比值超过该值，将会触发重写；
            2.auto-aof-rewrite-min-size 64mb：进行AOF文件重写时文件最小的体积，只要超过该体积就会触发重写；
    
    4.重写流程：
        1.AOF重写时可能会耗费较长时间，因此会fork一个子进程在后台进行重写，然后父进程会继续响应客户端请求；
        2.子进程在重写期间，由于主进程还在响应客户端请求，因此可能会导致数据库状态和AOF重写之后保存的状态不一致；为了解决这个问题，redis提供了一个重写缓冲区来保存子进程重写期间，主进程执行过的命令：
            // AOF块缓冲区结构
            typedef struct aofrwblock {
                // 当前已经使用的和可用的字节数
                unsigned long used, free;
                // 缓冲区
                char buf[AOF_RW_BUF_BLOCK_SIZE];
            } aofrwblock;
            重写缓冲区并非一个大块的内存空间，而是由10MB大小的节点组成的一个链表；
        3.在重写期间，主进程响应客户端请求时安装以下流程进行：
            1.执行客户端命令
            2.将指向后的命令追加到AOF缓冲区中；
            3.将执行后的写命令追加到AOF重写缓冲区中；
        
        4.重写细节：
            1.在触发BGREWRITEAOF命令之后，主进程调用rewriteAppendOnlyFileBackground函数，执行重写流程：
                1.检测当前是否正在进行重写，如果正在进行重写或者正在进行RDB持久化则返回错误信息；
                2.fork一个子进程，并创建父子进程的通信管道；
                    1.子进程无需响应客户端请求，因此子进程中首先关闭监听套接字；
                    2.创建临时文件，用来存储重写之后的AOF文件内容；
                    3.遍历数据库，将仍然有效的键值对数据以set命令的方式写入临时文件中；
                    4.从主进程中读取差异数据，然后更新至临时文件中；如果持续20ms读取不到数据，那么子进程终止读取数据；   
                    5.重写完成之后，原子性的将临时文件名称改为aof文件名；

    
