1.事务隔离级别：
    1.在原子性中说过，事务的原子性强调的是操作与结果的一致，而非操作本身的原子特征，所以事务并发执行时，当前事务执行期间可以被打断，然后执行其他事务的操作，那么会造成事务彼此之间看到其他已提交事务或未提交事务的执行结果；如果当前事务根据看到的这些结果继续执行其他操作可能会造成数据的不一致，因此必须对事务进行隔离，描述事务之间隔离程度的概念称为隔离级别；

    2.一个运行中的事务是否能够看到其他已提交事务或者未提交事务对数据的修改结果称之为事务之间的隔离程度，针对不同的隔离程度，定义了四种不同的隔离级别来表示，分别如下：
        READ UNCOMMITTED   读未提交(RU)
        READ COMMITTED     读已提交(RC)
        REPEATABLE READ    可重复读(RR)
        SERIALIZABLE       串行化执行(SER)  
    
    3.不同隔离级别下，事务之间具有不同的隔离程度，每个隔离级别理论上要求如下：
        1.READ UNCOMMITTED隔离级别下：要求当前事务运行期间每次查询总能看到最新未提交的事务对数据的修改；但是容易出现脏读的问题；
        2.READ COMMITTED隔离级别下：要求当前事务运行期间不能看到其他未提交事务对数据的修改，但是每次查询操作都能看到最新一个已提交事务对数据的修改；该要求下可以避免脏读问题，但是会出现不可重复读的问题；
        3.REPEATABLE READ隔离级别下：要求当前事务运行期间既不能看到其他未提交事务对数据的修改，也不能看到其他最新已提交事务对数据的修改；事务运行期间多次执行相同的查询操作必须得到相同的结果；理论上按照该要求，在RR隔离级别下不会再出现不可重复读的问题，但是会出现幻读问题；
        4.SERIALIZABLE隔离级别下：
            要求事务与事务完全串行化执行，一个事务必须等待另一个事务提交之后才能开始；理论上可以完全避免所有问题；
        (在innodb引擎的实现中，该隔离级别下所有操作都需要先申请加锁，只有事务当前操作加锁成功，才能够开始执行，否则处于等待状态；)
        上述只是对于四种不同隔离级别的隔离要求，实际在实现时，innodb存储引擎通过不同的方式实现，对于不同隔离级别下的隔离效果和理论上的隔离要求之间略有出入；

    4.事务并发执行时，在不同的隔离级别下因为隔离程度的不同会有不同的问题产生，分别如下：
        1.READ UNCOMMITTED隔离级别下：
            会有脏读的现象发生，即一个事务读取到了另一个未提交事务对数据的修改；
        2.READ COMMITTED隔离级别下：
            不会有脏读的现象发生，但是会有不可重复读的现象发生，即一个事务在运行期间读取到其他已提交事务对数据的修改；
        3.REPEATABLE READ隔离级别下：
            不会有脏读和不可重复读的现象发生，但是会有部分幻读的现象产生，即一个事务运行期间其他已提交事务有新增数据行为；之所以称为有部分幻读现象，是因为在RR隔离级别下能够避免幻读，但是又无法完全避免幻读：mysql的innodb引擎在RR隔离级别下会通过Next-Key Lock加锁算法对条件范围加上间隙锁，能够保证在间隙范围内其他事务无法新增数据，可以避免幻读现象，但是mysql的RR隔离级别通过锁和MVCC共同实现，为了避免读写冲突，普通的SELECT查询通过多版本控制实现，查询操作并不会加锁，因此在事务运行期间，执行普通的查询操作，仍然无法避免幻读；
        4.有一种更新丢失问题如下：
            场景1：
                事务1                                                           事务2
                begin;                                                          begin;
                #将类型为1的用户改为类型2
                UPDATE user SET user_type = 2 WHERE user_type = 1;
                                                                                #将类型为1的用户改为类型3
                                                                                UPDATE user SET user_type = 3 WHERE user_type = 1;
                #提交
                commit;
                                                                                #提交
                                                                                commit
            上述这种场景，在理论上是会发生，但实际上在当前mysql中，任意一个隔离级别下都不会发生，因为在最低的RU隔离级别下，事务之间已经能够看到未提交事务对数据的修改，事务2执行并不会成功；
            但是对于下面两种逻辑上的更新丢失问题，却在任意一种隔离级别下都无法完全避免：场景如下：
            场景1：
                事务1                                                           事务2
                begin;                                                          begin;
                #读取用户金额:假设money=10
                SELECT money FROM user WHERE uid = 1;
                                                                                #读取用户金额:假设money=10
                                                                                SELECT money FROM user WHERE uid = 1;
                #将用户金额加10
                UPDATE user SET money = 10+10 WHERE uid = 1;
                                                                                #将用户金额加10
                                                                                UPDATE user SET money = 10+10 WHERE uid = 1;
                #提交
                commit;
                                                                                #提交
                                                                                commit
                此时，事务2会覆盖掉事务1对金额作出的修改；导致事务1对金额的更新丢失；

            场景2：
                事务1                                                           事务2
                begin;                                                          begin;
                #读取用户金额:假设money=10
                SELECT money FROM user WHERE uid = 1;
                                                                                #读取用户金额:假设money=10
                                                                                SELECT money FROM user WHERE uid = 1;
                #将用户金额加10
                UPDATE user SET money = 10+10 WHERE uid = 1;
                                                                                #将用户金额加10
                                                                                UPDATE user SET money = 10+10 WHERE uid = 1;
                                                                                #提交
                                                                                commit
                #提交
                commit;
                                                                                
                此时，事务1会覆盖掉事务2对金额作出的修改；导致事务2对金额的更新丢失；
        这种场景的核心就在于后续的更新操作需要基于前一步查询操作的查询结果，但是在四种隔离级别下，都不会阻塞事务2对数据的查询操作，最终导致其中一个事务的更新被覆盖；对于这种更新丢失可以通过以下两种方式避免：
            1.通过手动加排他锁，阻塞第一步的查询操作：
                select ... for update;
            2.通过将查询更新操作合二为一作为原子操作执行，阻塞更新操作：
                UPDATE user SET money = money+10 WHERE uid = 1;

    5.innodb存储引擎默认的隔离级别为RR隔离级别；原因和mysql的主从同步机制有关，具体如下：
        mysql中的主从同步通过binlog实现，而在mysql5.0版本之前，binlog采用的是statement格式，这种格式会按照commit顺序记录更新操作的sql；如果在RC隔离级别下，会因为提交顺序带来主从结果不一致的问题：
        场景1：
            事务1                                                           
                                                                            事务2
            begin;                                                          begin;
            #删除类型为5的所有用户
            DELETE FROM user WHERE utype < 5;
                                                                            #增加一个utype=4的用户
                                                                            INSERT INTO user(utype,uname) VALUES(4,'tom');
                                                                            #提交
                                                                            commit
            #提交
            commit;
        在master中，最终会有utype=4的用户添加，但是由于事务2先提交，事务1后提交，在binlog中会先记录增加的sql，后记录删除的sql；导致slave中没有utype=4的用户，造成主从不一致；解决上述场景带来的问题必须按照事务开始顺序提交，即提升隔离级别至RR级别，在RR级别下，执行范围更新时会通过Next-Key Lock在utype<5的范围添加间隙锁；事务2在添加一个utype=4的用户时，由于加锁不成功导致阻塞，直至事务1提交或者回退之后事务2才能提交；
        但是在mysql5.1版本之后，binlog新增了row这种格式，row格式下binlog是基于行的记录，并不会因为事务提交顺序带来主从不一致的问题，因此在允许接受不可重复读的场景下，推荐使用RC隔离级别，RR隔离级别由于Next-Key Lock的加锁算法会有间隙锁的存在，会增加死锁的概率，并且降低事务并发性能，实际情况下同一个事务执行两次相同查询的情况并不多，在这种情况下推荐使用RC隔离级别；
    
    6.隔离级别的实现方式：锁和MVCC
        1.READ UNCOMMITTED隔离级别下：仅通过锁机制来实现；
        2.READ COMMITTED隔离级别下：通过锁和MVCC共同实现
        3.REPEATABLE READ隔离级别下：通过锁和MVCC共同实现
        4.SERIALIZABLE隔离级别下：仅通过锁机制实现；

2.关于锁：
    1.Innodb中通过加锁来解决事务并发执行时读写、写写之间的冲突；加锁时会以sql为单位按照查询条件为索引加锁，加上的锁会持续至整个事务运行结束；innodb存储引擎同时支持表锁和行锁；
    2.行锁简介：
        1.行锁是指，加锁时以单条数据记录的索引为单位加锁；
        2.行锁按照类型不同分为共享锁和排他锁：
            共享锁：表示加上该锁的事务可以读取一行记录；
            排他锁：表示加上该锁的事务可以删除或者更新一行记录；
        3.为了保证事务并发执行时的数据安全，共享锁和排他锁有不同的兼容性，具体如下：
                    X         S 
            X       0         0
            
            S       0         1

            其中，0表示两种锁互不兼容，1表示两种锁互相兼容；多个事务不能同时持有互不兼容的锁，但是可以同时持有互相兼容的锁；并且在添加互不兼容的锁时会造成阻塞等待，如果事务之间互相等待对方持有的锁会造成死锁；
        
    3.意向锁简介:
        1.Innodb支持多粒度锁定，既支持行级锁也支持表级锁，那么在添加表级锁时需要先判断是否有事务已经对某行数据加锁来避免锁冲突；为了能够高效检测这种情况，Innodb提供了意向锁机制，在加行锁时数据库会先自动申请加上相应的意向锁，那么其他事务添加表锁时也会先检测是否已经有意向锁，没有的话再添加表锁；意向锁分为意向共享锁和意向排它锁：
            意向共享锁：表示事务希望获得行锁中共享锁；
            意向排他锁：表示事务希望获得行锁中的排他锁；
        2.同样为了保证事务并发执行时的数据安全，意向锁和行锁有不同的兼容性，具体如下：
                    X         S         IX      IS
            X       0         0          0       0
            
            S       0         1          0       1

            IX      0         0          1       1

            IS      0         1          1       1
    
    4.Innodb存储引擎支持三种不同的加锁算法，分别如下：
        Record Lock:
            1.表示行锁，即以单条数据记录为单位对数据加锁；
            2.Innodb的锁基于索引实现，因此行锁实际上锁住的是数据记录上面的索引；
            3.具体加锁根据查询方式、查询条件、条件是否索引、是否聚集索引都有关系；
        Gap Lock:
            1.间隙锁，即对条件间隙加锁；所谓条件间隙是指当前条件范围内，数据库中实际存在的数据记录以外的索引；
            2.间隙锁只包括条件间隙，并不包括数据库中符合条件且实际存在的数据记录，符合条件的记录本上并未加锁；
        Next-Key Lock:
            1.Record Lock和Gap Lock互相结合的一种加锁方式；即锁定条件间隙也锁定数据记录本身；
            2.在RR隔离级别和SERIALIZABLE隔离级别下采用的就是这种加锁方式；

    5.不同sql操作下的加锁分析：
        1.sql具体加锁情况跟四个条件有关：
            1.隔离级别：RU、RC、RR、SERIALIZABLE
            2.sql类型：SELECT、SELECT...FOR UPDATE、SELECT...LOCK IN SHARE MODE、UPDATE、DELETE
            3.条件列类型：是否聚集索引列、是否非聚集索引列、是否非索引列
            4.查询方式：精确查询、范围查询
        2.具体加锁结论：
            1.SELECT操作：
                1.RU隔离级别、范围查询|精确查询、条件列任意索引类型：加共享锁、并且读完立即释放锁；
                2.RC/RR隔离级别、范围查询|精确查询、条件列任意索引类型：通过MVCC实现，无需加锁；
                3.SERIALIZABLE隔离级别、范围查询|精确查询、条件列任意索引类型：以Next-Key Lock的方式加共享锁；
            2.SELECT ... FOR UPDATE/SELECT ... LOCK IN SHARE MODE/DELETE/UPDATE操作：
                1.RU隔离级别、范围查询|精确查询：
                    条件列聚集索引：对符合条件的数据记录行聚集索引加锁；
                    条件列非聚集索引：对符合条件的数据记录行非聚集索引和聚集索引同时加锁；
                    条件列非索引：会全表扫描，在扫描过程中会对每一行记录的聚集索引加锁，然后检测是否符合条件，若不符合条件立即释放锁；最终只对符合条件的数据行加索引；
                2.RC隔离级别、范围查询|精确查询：
                    条件列聚集索引：对符合条件的数据记录行聚集索引加锁；
                    条件列非聚集索引：对符合条件的数据记录行非聚集索引和聚集索引同时加锁；
                    条件列非索引：会全表扫描，在扫描过程中会对每一行记录的聚集索引加锁，然后检测是否符合条件，若不符合条件立即释放锁；
                3.RR隔离级别：
                    精确查询：
                        条件列聚集索引：对符合条件的数据记录行聚集索引加锁；
                        条件列非聚集索引：对符合条件的数据记录行非聚集索引加读锁或者写锁和聚集索引加读锁；并在条件列两侧加间隙锁；
                        条件列非索引：通过Next-Key Lock的方式加锁，记录本上加行锁，全表间隙加Gap Lock
                    范围查询：
                        条件列聚集索引：会通过Next-Key Lock的方式加锁；范围为条件范围；(记录本身加行锁，其余间隙加Gap Lock)
                        条件列非聚集索引：符合条件的记录非聚集索引上会被加上行锁或者写锁，聚集索引上加读锁，然后会在条件间隙加Gap Lock;
                        条件列非索引：会通过Next-Key Lock的方式加锁；记录本上加行锁，全表间隙加Gap Lock
                4.SERIALIZABLE隔离级别下：
                    精确查询：
                        条件列聚集索引：对符合条件的数据记录行聚集索引加锁；
                        条件列非聚集索引：对符合条件的数据记录行非聚集索引加读锁或者写锁和聚集索引加读锁；并在条件列两侧加间隙锁；
                        条件列非索引：通过Next-Key Lock的方式加锁，记录本上加行锁，全表间隙加Gap Lock
                    范围查询：
                        条件列聚集索引：会通过Next-Key Lock的方式加锁；范围为条件范围；(记录本身加行锁，其余间隙加Gap Lock)
                        条件列非聚集索引：符合条件的记录本的非聚集索引上会被加上行锁或者写锁，聚集索引上加读锁，然后会在条件间隙加Gap Lock;
                        条件列非索引：会通过Next-Key Lock的方式加锁；记录本上加行锁，全表间隙加Gap Lock
    
    5.死锁： 
        1.因为锁与锁之间兼容性的原因，一个事务在对其他事务锁定的资源添加与之互斥的锁时会阻塞等待；如果事务在运行期间互相等待对方持有的锁，事务都会阻塞等待，如果没有外力干涉的话会造成事务都无法继续向下执行，这种现象称之为死锁；
        2.解决死锁的方式就是要打破互相等待的僵局，理论上来讲有三种方式：
            1.立即回滚：一旦发生阻塞等待，立即回滚当前事务；此种方式代价太大，如果竞争严重的话可能导致事务都无法正常向下执行，并且高权重的事务回滚代价太大；
            2.超时回滚：一旦发生阻塞等待，设置超时时间(innodb中通过innodb_lock_wait_timeout设置超时时间)，等待时长超过超时时间之后立刻回滚！但是超时回滚无法确定事务权重，如果事务本身权重很高，回滚代价会比较大；
            3.死锁检测：innodb还实现了wait-for-graph(等待图)的方式进行死锁检测；等待图需要数据库保存以下两种信息：1.锁的信息链表、2.事务等待链表；在Innodb1.0版本之后，Innodb在INFORMATION_SCHEMA架构下添加了INNODB_TRX、INNODB_LOCKS、INNODB_LOCKS_WAITS三张表；其中INNODB_TRX存储着事务的执行概况，其中INNODB_LOCKS存储着锁争用的概况，INNODB_LOCKS_WAITS中存储着事务与其等到的锁的情况；通过上述三个表即可获取到锁的信息链表和事务等待链表！
        3.查看事务执行概况：INNODB_TRX
            INNODB_TRX中主要的字段及含义如下：
                trx_id：事务唯一id
                trx_state：当前事务状态
                trx_started：事务开始时间
                trx_requested_lock_id：等待事务的锁id，如果事务的trx_state为LOCK WAIT时，那么该值就表示当前事务等待之前事务占用锁的id，如果trx_state的值不为LOCK WAIT，那么该字段为null；
                trx_wait_started：事务等待开始的时间；
                trx_weight：事务的权重，当发生死锁时，系统会根据该值选择权重最小的事务回滚；
                trx_mysql_thread_id：mysql中的线程id；
                trx_query：事务运行的sql语句；
            
            通过INNODB_TRX表可以查询当前有哪些事务正在运行，事务的运行状态如何，事务当前运行的sql语句等详细信息；
        
        4.查看当前数据库中加锁的概况：INNODB_LOCKS
            INNODB_LOCKS中主要的字段及含义如下：
                lock_id：锁的id
                lock_trx_id：事务的id
                lock_mode：锁的模式
                lock_type：锁的类型、表锁还是行锁
                lock_table：要加锁的表
                lock_index：锁住的索引
                lock_space：锁对象的space_id
                lock_page：事务锁定页的数量，若是表锁
                trx_state：当前事务状态
                trx_started：事务开始时间
                trx_requested_lock_id：等待事务的锁id，如果事务的trx_state为LOCK WAIT时，那么该值就表示当前事务等待之前事务占用锁的id，如果trx_state的值不为LOCK WAIT，那么该字段为null；
                trx_wait_started：事务等待开始的时间；
                trx_weight：事务的权重，当发生死锁时，系统会根据该值选择权重最小的事务回滚；
                trx_mysql_thread_id：mysql中的线程id；
                trx_query：事务运行的sql语句；
            
            通过INNODB_TRX表可以查询当前有哪些事务正在运行，事务的运行状态如何，事务当前运行的sql语句等详细信息；
        5.查看当前数据库中事务等待锁的情况：INNODB_LOCKS_WAITS
            requesting_trx_id：申请锁的事务id
            requesting_lock_id：申请锁的事务申请的锁id
            blocking_trc_id：阻塞的事务id，即当前占有锁的事务id
            blocking_lock_id：阻塞事务占有的锁id；
            在该表中，可以查看当前数据库中哪些事务在等待锁，等待锁的id以及占有该锁的事务id信息，方便查看导致死锁的情况；
        
        6.对于死锁的排查一般有两种方式：
            1.查看死锁日志：show engine innodb status；可以看到当前锁的等待情况；
            2.手动查看innodb_trx、innodb_locks、innodb_locks_waits表，手动分析死锁情况；
        
    7.自增长列与锁：
        1.Innodb存储引擎内的自增长列有一个自增长计数器，在插入数据时，自增长列的数值是通过查询该自增长计数器的最大值，并在当前最大值基础上加1得到最新的数值；为了能够保证在事务并发执行下能够得到正确的计数器数值，在查询计数器数值时会加锁查询：select MAX(auto_inc_col) FROM t FOR UPDATE；但是该查询加的锁并不是等事务结束之后才释放的，而是在最新数值插入自增长列之后会立即释放，目的在于保证自增长列的插入性能，这种机制称为AUTO-INC Locking；
        2.对于AUTO-INC Locking机制而言会有两个问题：
            1.自增长列在有事务混滚时可能造成自增长列断层，自增长列的值会不连续；
            2.由于自增长列也要加锁，在大批量插入时，需要阻塞等待自增长列值计算结果，因此性能同样较差；
        3.在mysql5.1.2版本以上，提供了一种轻量级互斥量自增长机制，可以大大提高自增长列的插入性能；mysql中一共有三种模式来获取自增长列的值，并提供了一个参数来选择使用何种模式：innodb_autoinc_lock_mode，有三个值可取：0、1、2，默认是1，但是也可根据不同的插入类型选择不同的模式；
        4.mysql中按照插入类型不同，分为以下几类：
            1.insert-like：指所有的插入语句，如：INSERT、REPLACE、INSERT...SELECT、REPLACE...SELECT、LOAD DATA;
            2.simple-inserts：指在插入之前就能确定要插入的条数，如：INSERT、REPLACE；但是不包括INSERT ...ON DUPLICATE KEY UPDATE语句；
            3.bulk-inserts：在实际插入之前无法确定要插入的条数，如：INSERT...SELECT、REPLACE...SELECT、LOAD DATA;
            4.mixed-mode inserts：指在插入时，一部分值是确定的，一部分值时自增长的，包括INSERT ...ON DUPLICATE KEY UPDATE语句；
        5.innodb_autoinc_lock_mode参数在取0时，任何插入类型都采用AUTO-INC Locking的方式；在取1时，对于simple inserts采用轻量级互斥量的方式实现，对于bulk inserts采用AUTO-INC Locking的方式实现；取2时，无论何种插入类型，都采用轻量级互斥量的方式实现；默认情况下取1；
        6.对于myisam引擎和innodb引擎不同，myisam存储引擎在插入数据时会添加表锁，无需考虑并发插入的问题；
    
3.关于MVCC：
    1.MVCC概念:
        1.对同一条数据不能同时执行读和写操作，要么先读后写，要么先写后读，否则无法保证读取数据的安全；
        2.对于读写冲突的问题，通常都是通过加锁来实现读写顺序执行，但是这种方式效率比较低；因此Innodb实现MVCC机制以无锁的方式解决读写冲突；提升读写并发执行时的效率；即MVCC是用来解决事务并发执行时读写之间冲突的机制；
    
        2.MVCC，即Multiversion Version concurrency control，多版本并发控制，是通过数据记录的版本链结合快照的方式来读取数据的一种机制；通过MVCC可以以无锁的方式解决读和写操作之间的冲突，提升读写并发执行时的效率：
        
        3.MVCC工作原理：
            1.MVCC机制需要借助数据记录的版本链和快照来实现，通过数据记录的版本链来实现数据的读取，通过快照来确定版本链中当前事务可见且最新的版本；
            2.在事务修改数据之前，会先记录数据修改之前的版本内容和当前事务id到undolog中，然后将数据库中该条记录版本字段的值修改为undolog中旧记录的地址；
            3.多条数据记录通过版本字段就可以组成一个版本链；当另一个事务查询数据的时候，会先创建快照，记录当前活跃的事务id，然后通过比对当前事务id和数据库中活跃的事务id来确定当前事务可见且最新的版本；
            
            由于采用MVCC机制读取数据时，数据来自于版本链中的记录，无需锁定数据库中的数据本身，所以可以实现以无锁的方式来实现读写冲突；

    2.MVCC实现原理:
        要实现MVCC有两个要求：1.带有事务id的数据版本链；2.数据快照；
        1.带有事务id的数据版本链实现方式:
            innodb中通过三个隐藏字段和undo log配合来实现，具体如下：
            1.三个隐藏字段：
                DB_TRX_ID：
                    最后一次修改数据记录的事务id；记录当前数据最后一次是被哪个事务修改的；
                    事务id在开启事务时产生，全局唯一，趋势递增；

                DB_ROLL_PTR：
                    指向该数据记录上一个版本的指针，通过该指针即可查看上一个版本的数据信息；
                    版本之间通过该字段连接起来，形成版本链；

                DB_DEL_BIT：表示该数据的更新操作是删除操作；

                实际上，如果表中没有主键，innodb还会主动添加一个DB_ROW_ID的隐藏字段，作为当前表的主键；
            2.undo log：
                undo log包括两种类型：
                    1.insert undolog：
                        表示当前事务中执行的insert操作记录；
                        insert undolog只有对于保持事务的原子性有用，用来在事务的后续操作执行失败时进行回滚；事务提交之后会立即删掉；

                    2.update undolog;
                        表示事务中执行的update和delete操作记录；
                        update undolog对于保持事务原子性和实现MVCC均有用到；因此事务完成之后不会立即丢弃，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除
                        update undolog在MVCC中的作用就是存储数据的上个版本信息，
            3.隐藏字段和undolog配合实现版本链的方式:
                删除、更新一条数据时具体流程如下：
                    1.先将数据加锁，然后将当前数据复制一份存储在undolog中，那么undolog中的这份旧数据就是当前数据的上一个版本；
                    2.之后将数据表中的数据更新为新的数据内容，然后将数据记录行中的DB_TRX_ID更新为当前事务id，DB_ROLL_PTR指向undolog中旧数据的地址；
                数据表中数据更新之后的DB_ROLL_PTR的字段指向undolog中的旧数据；而undolog中的旧数据也有DB_ROLL_PTR字段，指向该旧数据的上一个版本，依次类推，就形成了该数据的一个版本链，通过DB_ROLL_PTR即可追溯到该数据的每一个版本；

        2.快照：
            1.快照的作用：
                快照起着确定不同数据版本对当前事务可见性的作用；
                有了数据记录的版本链之后，就可以从版本链中返回一个版本的数据给当前事务，但是当前版本链中可能既有当前事务提交的修改记录，也有其他已提交事物的修改记录，也有其他未提交事务的修改记录，因此不可能随意返回一个版本给当前事务，那么必须有一种机制来确定哪一个数据版本对当前事务可见，并且是最新的版本，这种机制就是快照；
            2.快照的使用：
                1.只有普通的select查询操作才会使用MVCC机制，其余类型的操作均使用加锁的方式；
            3.快照的创建时机：
                1.快照创建时机之和发起select读的时机有关，和开启事务的时机无关；
                2.对于RC隔离级别，每次发起select读都会新创建快照；对于RR隔离级别，只有首次发起select读才会创建快照；
            4.快照确定不同版本数据对当前事务可见性的方式：
                1.在创建快照的一刻起，会保存当前数据库中所有的活跃事务id，并记录最小的活跃事务id(up_limit_id)和下一个即将分配的事务id(当前事务id最大值+1,low_limit_id);
                2.获取数据表中当前数据的DB_TRX_ID，该DB_TRX_ID值是该数据记录最后一次被修改时的事务id，但是DB_TRX_ID表示的事务有可能已经提交，也有可能未提交；因此需要和当前活跃id列表进行比较：
                    1.如果DB_TRX_ID<up_limit_id：说明在创建该快照的那一刻之前，最后一次修改该记录的事务已经提交，那么数据表中该数据对当前事务可见，而且在MVCC机制中，数据表中的数据总是最新的版本，因此符合可见且最新的数据版本要求，那么将该数据返回给当前事务即可；
                    2.如果：up_limit_id<=DB_TRX_ID<low_limit_id，那么说明当前数据版本对应的事务还未提交，那么还需要判断DB_TRX_ID是否等于当前事务id:
                        1.如果DB_TRX_ID等于当前事务id，那么说明最后一次修改该数据的事务就是当前事务，那么该数据同样对当前事务可见；
                        2.如果不同，那么说明最后一次对该数据修改的事务不是当前事务，并且当前事务还未提交，那么当前数据版本对当前事务不可见，需要根据当前数据的DB_ROLL_PTR指针从undolog中查找上一个数据版本，然后继续按照上述逻辑比较；            
            
    3.关于快照读和当前读：
        1.关于快照读：
            在RC和RR隔离级别下，只有使用普通的SELEC(SELECT * FROM table)操作才会创建快照，并从快照中根据数据记录的版本链来读取数据；即在RC和RR隔离级别下，只有普通的SELECT操作才能避免读和写操作之间冲突，提升读写之间的并发效率；这种查询数据的方式称之为快照读；
        2.关于当前读：
             在RC和RR隔离级别下，使用SELECT * FROM table LOCK IN SHARE MODE和SELECT * FROM table FOR UPDATE、UPDATE操作、DELETE操作、INSERT操作在执行之前会先申请加锁，表明当前操作需要通过强制加锁的方式解决读写冲突；此时将不会再使用MVCC的方式，而是直接通过加锁读取数据库中最新的数据；这种操作称之为当前读；
    
    4.MVCC作用的隔离级别：
        MVCC只作用在RC和RR隔离级别下作用，解决读写之间的冲突，RU和SERIALIZABLE隔离级别并不会使用MVCC；原因如下：
        1.由于RU隔离级别要求当前正在运行中的事务能够读取到最新未提交事务对数据的修改结果，而MVCC是通过数据的版本链来实现的，只有事务提交之后当前数据才会增加一个版本记录，事务提交之前并不会产生新的版本记录，无法满足RU隔离级别对于数据读取的要求，因此MVCC并不适用于RU隔离级别；
        2.由于使用MVCC时，在快照读操作下会有幻读的问题，并不符合SERIALIZABLE隔离级别的要求，因此在该级别下也不适用MVCC；
    
    5.快照读在RC和RR级别下的不同点：
        1.快照读的结果和事务之间开启的先后顺序没有关系，只取决于在事务中第一次执行快照读的时机；比如事务1开启早于事务2，事务2中对数据做出修改，如果在事务1执行快照读之前，事务2已经commit，那么事务1执行快照读是可以读取到事务2的修改结果的；
        2.在RC隔离级别下，每次执行快照读时都会新创建快照，因此在RC隔离级别下，当事务中执行快照读总是可以看到最新已提交事务对数据做出的修改，符合RC隔离级别的要求；
        3.在RR隔离级别下，只有第一次执行快照读时才会创建快照，此后在执行快照读时，总是使用第一次创建的快照，因此在RR隔离级别下，多次执行相同的快照读看到的一定是同一个版本的数据，可以避免出现不可重复读的现象，符合RR隔离级别的要求；但是需要注意的是：在RR隔离级别下，如果先使用快照读查找数据，那么此时其他事务仍然可以对该数据修改，如果其他事务修改完成之后提交，再在当前事务中使用加锁的SELECT查找数据时仍然无法避免不可重复读的问题；除非一值使用快照读或者一直使用当前读或者先使用当前读后使用快照读；(RR隔离级别下无法完全避免幻读问题，其原因相同)；  