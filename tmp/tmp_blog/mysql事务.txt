事务：
    事务，在对数据库中数据操作时经常会用到事务的概念，什么是事务？看到很多地方都将事务定义为：由多个操作组成的一个不可分割的最小工作单元；但是什么才是不可继续分割的？原子才是不可继续分割的！上述定义仅仅只是事务的一个特性：原子性而已；实际上事务有四个特性：A(原子性)、C(一致性)、I(隔离性)、D(持久性)，这四个特性共同保证了业务中对数据库中数据操作的某种需求；因此应该将满足了ACID这四个特性的一系列操作称之为一个事务；

事务的特性：ACID
    A(Atomicity)：原子性；
        这里的原子性是指：组成事务的一组操作要么全部成功，要么全部失败；

        而原子性实现的重点在于后半句：要么全部失败；因为正常情况下，组成事务的一组操作是可以全部成功的，而且原子性并没有要求所有的操作一旦开始就必须成功不能失败，因此所有的操作都成功是一种自然而然的情况，不需要做什么特殊的处理来保证全部成功；然而一部分执行成功，一部分执行失败就要面临两种不同的局面：
            1.不关心失败的情况，成功的保持成功，失败的处于失败状态；
            2.从第一次失败的点开始，将之前已经成功的操作全部回退，让所有操作都处于失败状态，就当这一组操作从未发生过；
        事务必须对这两种局面做出选择，而原子性则选择第2种：回退已经成功的操作，让所有的操作都处于失败状态，就当这一组操作从未发生；对于innodb存储引擎通过undolog来实现这一特性；

        为何要回退保持全部失败的状态？
        是因为在实际业务中我们有对数据的一致性需求；就是说，在事务发生之前和事务发生之后，无论事务成功与否，数据在业务逻辑上都应该是一致的；如果一部分操作执行成功，而一部分操作执行失败，就有可能破坏数据的一致性；

        关于原子性的说明：
        原子性操作本意是指一个不可再分割的独立的最小的执行单元，在这个独立的执行单元执行期间，理论上是'一步'操作，就像是执行了一个指令一样，执行期间不会被其他操作打断的；但是这里的原子性并非指执行上的原子性，仅仅只是执行上的整体性，即组成事物的多条操作仅仅只是保证整体成功或者整体失败，但不会被当做一个指令对待，执行时是被当做多条指令分别执行，多条指令执行期间有可能会被其他事务打断而造成其他事务对当前事务的侵入，侵入的程度就是隔离级别，由事务的隔离性包保证；
    
    C(Consistency)：一致性；
        一致性是指，在事务发生前后，无论事务执行成功或者失败，事务所操作的数据在逻辑上都是一致的；

        这里的'一致'指的是数据库中数据值在事务发生前后逻辑的正确性，而不是数据在事务发生前后和谁相等；所谓的逻辑正确中的逻辑也仅仅只代表数据库相关操作的逻辑，并不代表业务的逻辑，数据库本身也无法去保证数据在业务中的逻辑正确性，业务中数据的一致性应该由业务保证；

        事务的一致性仅仅只是对事务执行结果的要求，这种要求是通过事务的原子性来实现的，即通过操作全体成功或者全体失败来达到数据库数据操作的逻辑正确性；

    I(Isolation)：隔离性；
        在原子性中说过，事务中的原子性并非指执行上的原子性，组成事务的多条操作在并发的情况下会被其他事务中的操作打断，如果两个或者多个事务所操作的数据没有交集，即便被打断也不会影响数据在当前事务中的一致性；但如果事务之间操作的数据有交集，那就有可能出现一个事务读取到另一个已提交或者未提交事务对数据的修改结果，如果事务中又基于读取到的这个结果进行下一步的允许，最终会给事务的一致性带来影响；因此必须对事务进行隔离，而描述事务之间隔离状态的特性称之为隔离性；

        隔离级别：
        之所以需要对事务进行隔离，是因为并发情况下对数据的读取或者修改操作有了竞争；那么要实现隔离性就是要消灭事务之间的竞争，使事务之间串行化执行；但实际上，发生竞争的情况有四种，实际业务也对不同的竞争情况有一定的容忍度，如果完全使得事务串行化执行虽然可以避免竞争的情况，但是并发执行效率也会大大降低，因此实际中会根据业务对竞争的容忍度设置不同的策略来避免竞争，这称之为隔离级别；

        隔离级别的实现：
        避免竞争通常情况下通过锁来解决，但是锁的使用代表悲观的态度，使用锁虽然可以实现不同的隔离级别，但是对于并发执行时的性能并不好，因此对于隔离级别的实现还会有MVCC的方式;

    D(Duration)：持久性；
        持久性是指对数据的修改，一旦完成，修改的结果就会持久的存在，永远不会丢失；称之为事务的持久性；

        既然不能丢失，那么修改的结果就必须持久化至磁盘中才可以，mysql中通过redolog来实现数据修改至磁盘的刷新操作；当然，不存在绝对的持久性，数据从内存刷新至磁盘中时，可能会出现各种影响刷盘的问题，比如程序突然crash、存储介质突然故障灯，因此只能尽可能保证数据持久化至磁盘中；对于innodb存储引擎通过redolog来实现事务的持久性；
事务类型：
    扁平事务：
        1.扁平事务是指组成一个事务的所有操作都在同一个层面，由BEGIN开始，由ROLLBACK或者COMMIT结束，在BEGIN和ROLLBACK/COMMIT之间的操作要么全部成功，要么全部失败；扁平事务是最常用的本地事务类型；
        2.扁平事务的编程方式：
            #关闭自动提交-开启事务
            SET AUTOCOMMIT = 0;

            #执行sql
            INSERT INTO test(name,age) VALUES('tom',23);

            #提交或者回滚事务
            COMMIT; 提交事务
            ROLLBACK;回滚事务

    带保存点的扁平事务：
        1.此类事务本质上仍然是扁平事务，但是可以设置保存点，在回退时可以指定回退到哪一个保存点；但是回退到指定保存点之后事务并未结束，只是表示当前事务处于指定的保存点而已，要想结束事务还需要使用COMMIT或者ROLLBACK回滚整个事务；
        2.带保存点的扁平事务：
            #关闭自动提交-开启事务
            SET AUTOCOMMIT = 0;

            #执行sql1
            INSERT INTO test(name,age) VALUES('tom',23);

            #设置保存点1
            SAVEPOINT 1;

            #执行sql2
            INSERT INTO test(name,age) VALUES('tom',23);

            #设置保存点2
            SAVEPOINT 2;

            #回滚到保存点1，此时事务中的sql2将会被回退，但是sql1并不会，而且当前事务也并未结束；需要继续使用COMMIT提交事务或者使用ROLLBACK回退事务；
            ROLLBACK TO 1;

            #提交或者回滚事务
            COMMIT; 提交事务
            ROLLBACK;回滚事务
    链式事务：
        事务与事务之间链式执行，类似于带有保存点的扁平事务；
    嵌套事务：
        由多层事务嵌套而成，顶层事务起着决定性作用；
    分布式事务：
        分布式环境下的扁平事务