1.关于ziplist：
    1.ziplist在redis内部作为list列表、hashmap、zset元素的存储结构；

2.关于ziplist结构：
    1.ziplist结构如下：
        |--zlbytes(32位)--|--zltail(32位)--|--zllen(32位)--|--entry1(整数)--|--entry2(字节串)--|--entry...--|--zlend(8位)--|
    2.ziplist结构详情：
        1.zlbytes：
            表示整个ziplist占用的内存空间大小；
            固定占用32位存储空间；
        2.zltail：
            表示ziplist中尾部entry节点相对于头部entry结点的偏移大小；
            固定占用32位存储空间；
        3.zllen：
            表示ziplist中entry结点的个数；
            占用2个字节，做多只能够表示65535个节点个数，如果ziplist中节点个数超过65535个时，需要遍历整个ziplist才能确定当前ziplist中的节点个数；
        4.entry：
            表示实际存储的数据元素；
            ziplist中存储的元素只有两种类型：整数和字节串，ziplist内部通过编码的方式高效的记录所存储的数据类型和数据内容；
        5.zlend：
            ziplist结束标志，固定为0xFF，即十进制的255；

3.关于ziplist中entry节点：
    1.entry结构：  
        1.每个entry节点有三部分组成：prevlength、encoding、data；其作用如下：
            1.prevlength中存储着当前节点前置节点的大小(字节)，该部分的作用在于实现ziplist的反向遍历；
            2.encoding中存储着当前节点的数据类型以及当前节点数据部分的长度(字节)；
            3.data中存储着当前节点的数据内容，有两种类型：整数或者字节串；
        2.具体结构如下：
            |--prevlength--|--encoding--|--data--|
        3.关于prevlength：
            1.preclength的长度为1个字节或者5个字节；在获取时会首先获取该部分的前1个字节，然后通过该字节的大小来计算前置节点的长度，具体如下：
                1.如果该字节内的数据小于254，那么表示该字节内的数据就是前置节点的长度，下个字节开始起就是encoding的内容；
                2.如果该字节内的数据等于254，那么表示前置节点的长度无法使用1个字节表示，该字节之后的四个字节中才存储着前置节点的长度，而enconding的内容从后四个字节结束之后开始算起；
        4.关于encoding：
            1.encoding中承担着区分entry节点中数据类型、数据长度的功能；其长度不固定，但整体上由两部分组成：
                 1.第一部分占2位，用来表示entry节点中存储的数据类型：
                    11：表示存储的是一个整数；
                    00：表示存储的是一个字节数少于2^6的字符串；
                    01：表示存储的是一个字节数少于2^14的字符串；
                    10：表示存储的是一个字节数少于2^32的字符串；
                    从其定义可见，ziplist内能够容纳的字符串其长度最大不能超过2^32；
                2.第二部分则和存储的数据类型有关：
                    1.对于整数：encoding长度固定为1个字节，但是该字节低6位的不同值表示不同大小的整数；
                        11000000：表示data区域存储的是一个16位大小的整数：|11000000|--16位整数--|
                        11010000：表示data区域存储的是一个32位大小的整数：|11010000|--32位整数--|
                        11100000：表示data区域存储的是一个64位大小的整数：|11100000|--64位整数--|
                        11110000：表示data区域存储的是24位有符合整数：|11110000|--24位整数--|
                        11111110：表示data区域存储的是8位有符号整数：|11111110|--8位整数--|
                        1111[0001~1101]：表示data存储的是1~13；并且直接存储在该字节的低4位中，并无data区域；

                    2.对于字符串：encoding分为三种情况，即按照字符串长度不同而分为的三种情况：
                        00xxxxxx：高2位存储的是00，表示data区域存储的是一个字节数少于2^6的字符串；并且该字节的低6位存储的是data区域的长度；
                        01xxxxxx,xxxxxxxx：高2位存储的是01，表示data区域存储的是一个字节数少于2^14的字符串；并且该字节的低6位和下一个字节中存储的是data区域的长度；
                        10------,32*x：高2位存储的是10，表示data区域存储的是一个字节数少于2^32的字符串；并且data区域的长度从下一个字节算起，后四个字节(即该字节后32位)均存储的是data区域长度；
        5.关于data:
            data中存储的就是具体的数据内容，分为整数和字节串两种；
4.添加删除元素：
    1.插入流程：
        1.确定插入位置为头部插入还是尾部插入；
        2.对待插入数据进行编码，确定是以整数方式插入还是字节数组方式插入；
        3.根据插入元素的大小以及当前ziplist的大小重新申请内存空间；
        4.如果是头部插入，则通过拷贝的方式将原ziplist中的数据后移，在后移的过程中还会检测后一个节点的prevlen空间是否能够容纳前一个节点的大小，如果能则不进行压缩，否则需要扩展；
        5.如果是尾部插入，则直接更新tail_offset即可；
        6.检测是否需要连锁更新；
        7.更新ziplist的zltail以及zllen值；
    
    2.关于连锁更新：
        1.引起连锁更新的原因：
            由于ziplist中的每一个节点都通过prevlength字段类保存前置节点的长度，而prevlength的长度只能取1个字节或者5个字节，那么会发生以下两种情况：
                1.连续有多个entry节点的prevlen长度都是1个字节，但是由于头部插入一个元素之后，导致其后置节点的prevlength需要变化为5个字节，而后置节点长度的变化又可能导致下一个后置节点prevlen需要调整，最终引起一连串的变化；
                2.连续有多个entry节点的prevlen长度都是5个字节，但是由于头部插入一个元素之后，导致其后置节点的prevlength需要调整到一个字节，而后置节点的下个节点同样需要调整，最终引起一连串的变化；
            上述两种情况称之为连锁更新，在redis中仅处理第一种情况引起的连锁更新，对于第二种情况，如果发现后置节点的prevlength过长也不会压缩；
    3.对于删除操作而言，删除之后的元素需要通过拷贝的方式向前或者向后移动，并且同样需要判断后置节点是否需要调整prevlength大小，严重的情况下同样会遇到连锁更新的问题；       
       
4.ziplist结构特点：
    1.在redis内部并没有为ziplist声明特定的结构体，而是按照ziplist结构的定义通过编码的方式实现；
    2.ziplist占用一段连续的内存空间，存储结构紧促，能够最大程度节省内存占用；但是该特点也导致ziplist在更新元素内容、插入元素、删除元素时需要relloc以及数据拷贝，极端情况下甚至出现连锁更新的问题；
    3.ziplist中除过存储元素本身信息以外，还存储了ziplist中元素的个数、ziplist占用内存空间大小等信息，相对于数组而言，获取列表中元素个数复杂度降低为O(1)，但是如果ziplist中元素个数超过2^16个，仍然需要遍历计算总数；
    4.ziplist中直接以整数或者字节串的方式保存数据信息，使用一个ziplist即可保存多种不同类型的数据，相比数组而言其存储效率更高；
    