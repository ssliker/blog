关于并发编程认知：
    1.关于并发编程：
        并发编程是和普通的编程相对而言的，普通的编程通常是只程序运行单进程单线程模式下，并发编程是指程序运行在多线程、多进程、多进程多线程模式下；普通的编程一般应对小流量场景，并发编程通常都是为了应对大流量场景提高服务的吞吐量；

    2.并发编程要解决的问题；
        普通编程和并发编程通常都需要解决三个问题：
            1.功能是否正确
            2.性能是否优秀
            3.链路是否稳定可靠
        但是普通编程和并发编程对这三个问题的关注点并不相同;
    3.关注点：
        1.对于功能是否正确：
            1.问题：单进程单线程模式下只需要关注业务逻辑本身是否正确就可以了，但是并发编程下，对于功能是否正确并不单单取决于业务逻辑，还取决于对共享数据的访问是否同步：在多线程、多进程并发执行的情况下，可能出现多个线程、进程读取到共公变量相同的初始值，又基于初始值做了更新操作，那么显然后提交的就会覆盖掉先提交的，造成一个线程或者进程的更新丢失；这只是由于多线程或者多进程无法保证原子性执行也就是无法同步执行导致的线程安全问题的一种情况；在多线程情况下还会因为线程间的可见性以及指令重排序带来其他问题；
            2.解决办法：
            这一点体现在业务场景中主要是两个方面：1.单进程内共享变量的问题、2.第三方数据源的操作；
            解决方法：
                单进程多线程场景：加锁：
                    悲观锁：synchronized、lock
                    乐观锁：原子类、数据库记录加版本号实现乐观锁、redis事务机制实现乐观锁；
                    借助第三方组件的原子操作指令实现原子性
                多进程间：加锁：
                    悲观锁：分布式锁：redis实现或者zookeeper实现
                    乐观锁：数据库记录加版本号、redis事务机制实现乐观锁
                    借助第三方组件的原子指令实现原子性
        2.对于性能是否优秀：
            这一点并发编程和单进程单线程处理的思路基本一致：
                1.使用缓存存储数据，加快数据的读取速度
                2.使用消息队列实现接口访问的异步效果，实现耗时操作和非耗时操作的解耦
                3.使用池化技术：比如连接池、线程池、避免反复创建资源浪费时间；
                4.能不需要实时的尽量避免实时处理；
                5.能静态化的尽量静态化
                6.水平扩展服务，通过负载均衡提升单个服务的可利用资源；
                7.对数据库做垂直分表、水平分表，甚至水平分库来提升数据库处理速度；

        3.对于链路稳定可靠：
            链路稳定可靠除过在部署结构上使用集群模式部署以外，还能够在业务逻辑上和技术上进一步处理：
                1.在业务上将热点分散；
                2.页面上使用过度动画掩盖服务延迟；
                3.页面上限制接口访问方式
                4.限流
                5.利用消息队列的消息堆积能力进行削峰；
                6.使用池化技术，比如线程池、连接池避免资源过度创建；
                7.熔断降级
                8.服务间调用使用线程池进行隔离；

分布式锁：
    1.redis:
        1.实现方式：
            set +nx命令、setnx命令；
            key作为锁的名称、value作为持有锁的线程或者进程
        2.利用原理：
            1.借助redis单线程处理客户端请求的特性实现多线程或者多进程的同步
            2.借助该命令只有在key不存在的情况下才能设置key的特性实现锁的唯一性
            3.借助过期时间防止持有锁的线程在崩溃之后无法及时释放锁，导致锁被抗住；
        4.常见问题：
            1.客户端崩溃，导致锁无法释放；
                解决措施：通过set+nx命令为锁加上有效期；
            2.客户端执行时间过长超过有效期，导致锁同时被两个客户端持有产生并发问题，并且可能出现一个客户端删掉锁，引发锁被连锁释放；
                解决措施：给表示锁的key的value设置成客户端id，在客户端删除锁的时候检查下当前持有锁的客户端是否是自己，尽量避免发生锁被连锁释放的问题；
            3.基于情况2.需要先get，然后del锁保证锁释放准确性，但是由于get和del并不是原子指令，可能出现get获取到的是当期客户端的锁，但是删除的时候锁已经被其他客户端持有；
                解决措施：使用lua脚本使用实现检测和删除的原子性；之所以能实现，是因为写在lua中的脚本本质上是通过eval/evalsha这两个命令来执行，对于redis而言，这是一条命令，一条命令没有执行完成之前，其他客户端只能等待；
        5.方式选择：
            使用set+nx命令；nx设置有效期，key设置锁的名称、value设置持有锁的客户端id；
            要求严格的情况下，可以使用lua脚本配合实现；
        6.更优选：redsisson和redlock
            1.关于redsisson：
                1.即是一个java的redis客户端，同时也实现了一些其他高级特性；利用redsisson实现分布式锁的话主要是利用RedissonLock这个类；本质上也是通过lua脚本实现的加锁和解锁；
                2.使用方式：
                    RedissonClient client = getClient();
                    Rlock rlock = client.getLock();
                    //加锁
                    rlock.lock();
                    //释放锁
                    rlock.unlock();
            2.关于redlock：
                是redis官方提出的一个分布式锁算法；要求redis实例必须是单实例部署方式部署多个实例、在获取锁时需要在超时时间内完成向每一个实例申请加锁，如果超过半数能够加锁成功，那么就认为当前客户端持有了锁；
    2.zookeeper创建分布式锁：
        1.原理：利用zk临时顺序节点的顺序特性以及监控特性实现分布式锁；
        2.zk节点类型：
            持久节点、持久顺序节点、临时节点、临时顺序节点
        3.获取锁流程：
            1.zk需要先创建一个持久节点表示锁节点，当第客户端想要获得锁时，需要现在ParentLock这个节点那下面创建一个临时顺序节点，lock1;
            2.接着加锁的客户端需要遍历ParentLock节点下面所有的临时顺序节点并排序，判断自己锁创建的节点lOCK1是不是最靠前的一个，如果是，则成功获得锁；否则第二个临时节点对应的客户端watch第一个节点，第三个watch第二个节点，一次形成监听连，在前一个释放锁之后后一个就会得到通知；
        4.释放锁：
            1.任务完成，客户端断开连接，显式释放掉锁；
            2.客户端崩溃，断开与zk的连接，显式释放掉锁；
        5.zk与redis分布式锁对比：
            1.zk加锁和上锁需要创建和删除临时节点，效率较低，redis仅仅只是删除和添加一个key，效率更高；
            2.zk通过watch的方式等待锁，redis需要客户端自旋等待锁。相比之下zk通信效率更高；
            3.zk无需考虑客户端崩溃导致超时的问题，实现方案更简单，redis需要考虑客户端崩溃超时的问题，方案比较复杂；
            4.zk可能产生并发问题，如果出现网络抖动，那么zk和客户端失去连接之后，可能认为客户端已经下线，导致后一个等待锁的客户端获取到锁；
        6.节点创建方式：
            持久节点：create /节点位置路径 节点名称
            临时节点：create -e /接点位置路径 节点名称
            顺序节点：加锁-s参数即可；
        7.zk其他分布式锁方案：
            1.zk可以使用持久节点实现，但是像redis一样，可能出现客户端崩溃导致死锁
            2.zk可以使用单个节点的唯一性实现，但是在锁被释放时可能引发惊群效应；
        8.关于zk：
            1.zk时一个分布式存储系统，通过节点存储数据，然后以linux目录路径的方式组织节点的关系；
            2.zk可以用作服务注册和发现中心、分布式锁、统一命名服务、分布式配置中心、集群管理；
        9.关于znode节点：
            1.znode分为四种类型：
                1.持久节点
                2.持久顺序节点
                3.临时节点
                4.临时顺序节点
        10.关于模式：
            zk集群有两种运行模式：
                1.恢复模式：集群刚刚启动或者leader崩溃之后会进入恢复模式，在恢复模式下主要做两个事情：leader的选举、leader与flower节点的同步；
                2.广播模式：当leader被选举出并完成和flower节点的数据同步之后，就会进入广播模式，在广播模式下主要完成两个事情：处理客户端请求、完成新加入节点的数据同步；
        11.zk监听机制：
            监听的场景主要有两个：znode中数据的变化、znode节点的增减；
        12.应用场景：
            1.分布式配置中心：将配置信息存储在znode节点中，然后让服务监听znode节点内容的变化，当存放配置信息的znode节点内容被修改之后，客户端可以立即被通知到；
            2.集群管理：通过临时节点来实现服务上线和下线的发现、也可以通过临时顺序节点来实现将最小的znode节点对应的服务选举为主节点；
        13.zk集群角色类型：
            1.leader、follower、observer节点；
            2.leader：一个集群中只能有一个leader、负载处理客户端的写请求，以及与其他follower节点的数据同步；
            3.follower节点：负责处理客户端的读请求，并将接收到的写请求转发给leader、并在leader崩溃之后参与leader选举；
            4.observer节点：与Follower节点类似，但是不参与leader的选举；
        14.服务状态：
            服务状态时指集群中各个节点的状态，存储在各个节点中；
            Looking：表示当前集群中暂无主节点，需要选举leader节点；
            fllowing：表示当前服务是一个follower节点
            leading：表示当前服务节点是一个leader节点；
            observing：表示当前服务节点是一个observe节点；
        15.集群状态：(zab协议中定义的四种状态)
            1.election：集群进入徐那句状态，正在选举一个leader
            2.discovery：表示leader已经选举出，follower节点正在响应leader的心跳，检测leader角色是否更改，也就是集群中的follower正在确认leader节点；
            3.synchronization：表示整个集群已经完成leader节点的确认，leader节点将会把数据同步到各个节点，保证集群数据的一致性；
            4.broadcast：集群进入广播模式；开始对外提供服务；
        16.选举规则：
            1.投票给epoch更高的节点；
            2.epoch相同，则投票给事务id更高的节点；事务id越高说明当前节点执行的事务更新，数据更完整；
            3.epoch相同，事务id也相同，则投给serverID更高的节点；
        17.投票流程：
            1.服务在新启动、崩溃后各个节点会进入LOOKING状态；开始选举新leader；
            2.服务需要先投给自己一票，选举自己，然后将投票信息广播出去；
            3.其他节点也在广播自己的投票信息，索引节点还需要接收别的节点的投票信息；然后根据投票策略来修改自己的投票信息；
            4.如果需要修改，那么还需要广播修改之后的信息，
            5.检测是否有节点已经有超过一半的投票信息，如果有，那么具备一半投票的节点就成为主节点；集群中的其他节点都要修改自己的状态为follower节点；
            6.完成选举过程；
        18.广播模式：
            1.zk集群在选举出leader之后就会进入广播模式；
            2.zk集群在广播中具有以下特点：
                1.可靠传递
                2.全局有序
                3.因果有序
            3.修改操作流程：
                
                1.leader节点收到客户端写请求时会生成一个事务id；
                2.leader开始广播事务，
                3.follower接收到事务广播信息之后会开始将事务写入本地磁盘，写入成功之后返回一个ack给服务端；
                4.leader节点收到过半的ack之后，开始提交本地事务；并广播事务提交信息；
                5.follower节点接收到事务提交广播信息之后开始提交本节点的事务；

                1.zk通过两阶段提交的方式实现集群中节点数据的一致性的；
                2.zk中的一致性并不是强一致性，只要超过半数的follower节点返回ack就会提交事务；
                3.在节点之前会维护一个FIFO先进先出的对列，来保证节点收到的消息时有序的；
                4.通过事务idzxid来保证事务在全局的有序性；节点在收到事务广播消息之后会先检测该事务的id是否大于本地最大事务id，如果大于那就可以接受，否则直接抛弃；