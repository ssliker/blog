Innodb存储引擎下SELECT查询分析(mysql5.6)：show engine innodb status;
根据Innodb加锁特点和mysql中的查询类型以及事务之间的隔离级别不同，SELECT查询分析主要聚焦在四个点：查询类型、隔离级别、条件列索引类型、查询方式(范围查询/精确查询)
1.SELECT类型：
    对于RC和RR级别，mysql中存在两种查询方式：快照读和当前读，对于RU级别，则没有快照读和当前读的区别；
    快照读：
        1.快照读是指在执行`SELECT`语句时，会对数据库中数据建立快照并从快照中查询数据，所查询的数据版本会根据不同隔离级别有所不同，在查询过程中无需加任何锁,并且能够立刻得到查询结果；
        2.快照读方式：在事务隔离级别在RC/RR级别时的`select ... from table`；

    当前读：
        1.当前读是指始终从数据库中读取此刻最后一个已提交事务对数据的修改，不同的查询方式、不同的隔离级别、条件列索引类型不同均需要加不同的锁，如果加锁失败将无法立即得到查询结果，会一直阻塞等待至加锁成功；
        2.当前读方式：
            1.SERIALIZABLE级别的`select * from table`操作,SERIALIZABLE级别下的`select * from table`会自动加上lock in share mode;
            2.RU/RC/RR级别下的`select ... lock in share mode`操作和`select ... for update`操作;

2.SELECT操作加锁分析：
    1.快照读加锁特征分析：
        1.快照读+条件列是聚簇索引：
            RC级别：不加任何锁；
            RR级别：不加任何锁；

        2.快照读+条件列非聚簇索引：
            RU级别：不加任何锁；
            RC级别：不加任何锁；
            RR级别：不加任何锁；

        3.快照读+条件列非索引：
            RU级别：不加任何锁；
            RC级别：不加任何锁；
            RR级别：不加任何锁；

        结论：只要是快照读，无论条件列索引类型，无论查询方式、无论隔离级别，均不加任何锁！

    2.当前读加锁特征分析：
        1.当前读+RU/RC级别：
            1.条件列是聚簇索引：
                1.lock in share mode
                    结论：只对符合条件的数据行加共享锁(S锁)；
                    加锁过程：由于条件列是聚簇索引，所以是通过对聚簇索引树符合条件的聚簇索引加锁实现对数据行加锁；
                2.for update
                    结论：只对符合条件的数据行加排他锁(X锁)；
                    加锁过程：由于条件列是聚簇索引，所以是通过对聚簇索引树符合条件的聚簇索引加锁实现对数据行加锁；
            2.条件列时非聚簇索引：
                1.lock in share mode
                    结论：对符合条件的数据行加共享锁(S锁)；
                    加锁过程：由于条件列是非聚簇索引，所以会先对非聚簇索引树符合条件的非聚簇索引加锁，然后通过非聚簇索引在聚簇索引树查找符合条件的聚簇索引，并对符合条件的聚簇索引加锁实现对数据行加锁；
                2.for update
                    结论：对符合条件的数据行加排他锁(X锁)
                    加锁过程：由于条件列是非聚簇索引，所以会先对非聚簇索引树符合条件的非聚簇索引加锁，然后通过非聚簇索引在聚簇索引树查找符合条件的聚簇索引，并对符合条件的聚簇索引加锁实现对数据行加锁；
            3.条件列非索引：
                1.lock in share mode
                    结论：对符合条件的数据行加共享锁(S锁)(会对整个列加锁，其他事务通过当前列更新时会阻塞)
                    加锁过程：由于条件列非索引，所以会逐行扫描全表，并对扫描到的每一行加锁，接着判断数据行是否符合条件，如果不符合条件讲会释放掉加的锁；重复上述动作至表扫描结束；
                2.for update
                    结论：对符合条件的数据行加排他锁(X锁)(会对整个列加锁，其他事务通过当前列更新时会阻塞)
                    加锁过程：由于条件列非索引，所以会逐行扫描全表，并对扫描到的每一行加锁，接着判断数据行是否符合条件，如果不符合条件讲会释放掉加的锁；重复上述动作至表扫描结束；
            结论：
            1.当前读、RU/RC级别下：
                1.无论条件列索引类型、无论精确查询还是范围查询；均只为符合条件的数据行加行级锁(共享锁/排他锁)，但是加锁过程不同；
                2.特别注意的是，如果条件列是非聚簇索引列时,会导致其他事务中无法再通过该条件列对其他数据行数据进行更新！就像是对列加了锁一样！

        2.当前读+RR/SERIALIZABLE级别：
            1.条件列是聚簇索引:
                1.lock in share mode:
                    结论：
                        1.如果条件是精确查询(=)，那么只对符合条件的数据行加共享锁(S锁)；
                        2.如果条件是范围查询(>,>=,<,<=)，那么会对符合条件的数据行加共享锁(S锁)，并且会在条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)之间加间隙锁；会有局部锁表现象
                    加锁过程：由于条件列是聚簇索引，所以是通过对聚簇索引树符合条件的聚簇索引加锁实现对数据行加锁；但是不同的在于如果条件是范围查询，还会对范围以内的数据加上间隙锁；
                2.for update：
                    结论：
                        1.如果条件是精确查询(=)，那么只对符合条件的数据行加排他锁(X锁)；
                        2.如果条件是范围查询(>,>=,<,<=)，那么会对符合条件的数据行加排他锁(X锁)，并且会在条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)之间加间隙锁；会有局部锁表现象
                    加锁过程：由于条件列是聚簇索引，所以是通过对聚簇索引树符合条件的聚簇索引加锁实现对数据行加锁；但是不同的在于如果条件是范围查询，还会对范围以内的数据加上间隙锁
            2.条件列时非聚簇索引：
                1.lock in share mode：
                    结论：
                        1.如果当前条件列是唯一索引，那么查询时加锁情况和条件列是聚簇索引加锁情况基本相同，唯一不同的在于加锁过程：此时，会先对非聚簇索引树的非聚簇索引加锁，后对聚簇索引树的聚簇索引加锁；
                        2.如果当前条件列不是唯一索引：
                            1.条件列是精确查询(=)，那么会对数据行加共享锁(S锁)；并且会在当前条件列 两侧 相邻的区间加上间隙锁：条件列查询值与前一个条件列值之间、条件列查询值与后一个条件列值之间：(prev,value)(value,next)
                            2.条件列是范围查询(<,<=,>,>=)，那么会对数据行加共享锁(S锁)，并且会在条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)
                2.for update
                    结论：
                        1.如果当前条件列是唯一索引，那么查询时加锁情况和条件列是聚簇索引加锁情况基本相同，唯一不同的在于此时，会先对非聚簇索引树的非聚簇索引加锁，后对聚簇索引树的聚簇索引加锁；
                        2.如果当前条件列不是唯一索引：
                            1.条件列是精确查询(=)，那么会对数据行加排他锁(X锁)；并且会在当前条件列 两侧 相邻的区间加上间隙锁：条件列查询值与前一个条件列值之间、条件列查询值与后一个条件列值之间：(prev,value)(value,next)
                            2.条件列是范围查询(<,<=,>,>=)，那么会对数据行加排他锁(X锁)，并且会在条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)
            3.条件列非索引：
                1.lock in share mode：
                    结论：全表所有记录加共享锁(S锁)，并且会对表中相邻两行以及最大值至正无穷和最小值至负无穷加上间隙锁；
                2.for update
                    结论：全表所有记录加排他锁(X锁)，并且会对表中相邻两行以及最大值至正无穷和最小值至负无穷加上间隙锁；

        结论：
            1.当前读、RU/RC级别下：
                1.无论条件列索引类型、无论精确查询还是范围查询；均只为符合条件的数据行加行级锁(共享锁/排他锁)，但是加锁过程不同；
                2.特别注意的是，如果条件列是非聚簇索引列时,会导致其他事务中无法再通过该条件列对其他数据行数据进行更新！就像是对列加了锁一样！
            2.当前读、RR/SERIALIZABLE级别：
                1.条件列为聚簇索引/唯一的非聚簇索引：
                    1.精确查询：只为符合条件数据行加行级锁(共享锁/排他锁)；
                    2.范围查询：只为符合条件数据行行级锁(共享锁/排他锁)，并在条件列的条件范围内加间隙锁，有局部锁表的现象；
                                间隙锁范围：条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)
                2.条件列为非唯一非聚簇索引：
                    1.精确查询：只为符合条件数据行加行级锁(共享锁/排他锁)，并在条件值两侧最近相邻索引值区间加间隙锁；(由于索引列非唯一，因此为了避免当前事务查询数据时其他事务插入和条件值等值的数据行，比如条件值是5，数据表中比5小的索引值是2，比5大的索引值是7，那么会在(2,5)和 (5,7)之间加间隙锁)
                                间隙锁范围：条件列查询值与前一个条件列值之间、条件列查询值与后一个条件列值之间：(prev,value)(value,next)
                    2.范围查询：只为符合条件数据行加行级锁(共享锁/排他锁)，并在条件列的条件范围内加间隙锁，有局部锁表的现象；
                                间隙锁范围：条件列查询值至条件列最小值min相邻两行以及(-∞,min) 或者 条件列查询值至条件列最大值max相邻两行以及(max,+∞)
                3.条件列为非索引：
                    1.精确查询：全表数据行加行级锁(共享锁/排他锁)，并在全表范围内加间隙锁，有锁表的现象；
                                间隙锁范围：表中相邻两行以及最大值至正无穷和最小值至负无穷；(-∞,+∞)
                    2.范围查询：全表数据行加行级锁(共享锁/排他锁)，并在全表范围内加间隙锁，有锁表的现象；
                                间隙锁范围：表中相邻两行以及最大值至正无穷和最小值至负无穷；(-∞,+∞)

3.SELECT查询结果分析:
    1.快照读：
        1.快照读+条件列(非索引列/非聚簇索引列/聚簇索引列)+RU级别：
            RU隔离级别下有以下两个基本特征：
                1.RU隔离级别通过锁的方式实现，并不会创建快照；
                2.RU隔离级别下，由于加锁的特征，总能看到最后一次未提交事务对数据的修改，如果没有未提交事务，那么看到的就是最后一次已提交事务对数据的修改；
                
            因此在RU隔离级别下执行多次查询会有以下现象：
                    事务1                                                                 事务2
                set autocommit = 0;                                                     set autocommit = 0;

                #此时还未有其他未提交事务对数据修改，因此查询结果为0；
                select umoney from uinfo where uname = 'tom';                 
                                                                                        #更新umoney=1
                                                                                        update uinfo set umoney = 1 where unam = 'tom';
                #由于事务2对数据做了修改，事务1能够看到，因此查询umoney结果是1；
                select umoney from uinfo where uname = 'tom';                       
                                                                                        #提交
                                                                                        commit;
                #事务2已经提交，且无其他未提交事务对数据的修改，因此查询结果为1；
                select umoney from uinfo where uname = 'tom';   

                commit;

            结论：RC级别下，单次查询操作均只能获取快照中最后一次已提交事务对数据的修改，多次查询由于快照的不同，可能查询结果不同；
        2.快照读+条件列(非索引列/非聚簇索引列/聚簇索引列)+RC级别：
            RC隔离级别下有以下两个基本特征：
                1.RC隔离级别下，仅能看到最后一次已提交事务对数据的修改；
                2.RC隔离级别通过MVCC的方式实现，在事务中每次执行查询时都会创建快照；
            因此在RC隔离级别下执行多次查询会有以下现象：
                    事务1                                                                 事务2
                set autocommit = 0;                                                     set autocommit = 0;

                #执行查询，建立快照；
                #快照中最后一次已提交事务对umoney的修改结果为0；因此查询结果为0；
                select umoney from uinfo where uname = 'tom';                 
                                                                                        #更新umoney=1
                                                                                        update uinfo set umoney = 1 where unam = 'tom';
                #执行查询，重新建立快照；
                #虽然重建快照，但是事务2并未提交，因此看到的umoney仍然是0；
                select umoney from uinfo where uname = 'tom';                       
                                                                                        #提交
                                                                                        commit;
                #执行查询，重新建立快照；
                #此时由于事务2已经提交，umoney被修改为1，因此查询结果为1；
                select umoney from uinfo where uname = 'tom';   

                commit;

            结论：RC级别下，单次查询操作均只能获取快照中最后一次已提交事务对数据的修改，多次查询由于快照的不同，可能查询结果不同；

        3.快照读+条件列(非索引列/非聚簇索引列/聚簇索引列)+RR级别：
            RR隔离级别下有以下两个基本特征：
                1.RR隔离级别下，仅能看到最后一次已提交事务对数据的修改；
                2.RR隔离级别通过MVCC的方式实现，仅在事务中第一次执行查询时会创建快照，其他查询会使用第一次查询建立的快照；
            因此在RC隔离级别下执行多次查询会有以下现象：
                    事务1                                                                 事务2
                set autocommit = 0;                                                     set autocommit = 0;

                #执行查询，建立快照
                #快照中最后一次已提交事务对umoney的修改结果为0；因此查询结果为0；
                select umoney from uinfo where uname = 'tom';                 
                                                                                        #更新umoney=1
                                                                                        update uinfo set umoney = 1 where unam = 'tom';
                #执行查询，不再重建快照，此看到的umoney仍然是0；
                select umoney from uinfo where uname = 'tom';                       
                                                                                        #提交
                                                                                        commit;
                #执行查询，不再重建快照，此看到的umoney仍然是0；
                select umoney from uinfo where uname = 'tom';   

                commit;

            结论：RR级别下，单次查询操作均只能获取快照中最后一次已提交事务对数据的修改，多次查询由于只会使用第一次查询建立的快照，因此只会
    2.当前读:
        当前读时由于会对查询的数据添加共享锁或者排他锁：
            1.如果未加锁成功，那么将会一直阻塞直至加锁成功，在加锁成功之前无法读取到数据；
            2.一旦加锁成功，其他事务将无法对所查询数据进行修改，因此在整个事务执行期间，所有查询都得到同一个数据；不会像快照读那样不同隔离级别多次查询可能有不同的查询结果；