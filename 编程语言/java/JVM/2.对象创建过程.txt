1.对象的创建方式：
    1.使用new关键字：
        Color color = new Color();
    2.使用Class类的newInstance方法： 
        Class class = Color.class;
        class.newInstance();
    3.使用Constructor类的newInstance方法： 
        Class class = Color.class;
        Constructor con = class.getDeclaredConstructor();
        con.newInstance();  
    4.使用clone方法  
        Color color = co.clone();

2.对象中存储的内容：
    1.对象由三部分组成：
        对象头
        实例数据
        对齐数据
    2.对象头由两部分组成：
        Mark Word
        类型指针
        (数组对象还有数组长度)
        Mark Word:
            Mark Word是一段动态的内存结构；会根据当前对象的不同状态来存储不同的数据，其动态性在满足存储数据需要的基础上能够尽力减少内存的占用；
            Mark Word占用的内存空间在为对象分配内存时一起分配，其中的值在对象的内存空间分配完成之后初始化；
            Mark Word在32位的虚拟机和64位的虚拟上其结构有所不同：
            32位虚拟机：
                |-------------------------------------------------------|--------------------|
                |                  Mark Word (32 bits)                  |       State        |
                |-------------------------------------------------------|--------------------|
                | identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
                |-------------------------------------------------------|--------------------|
                |  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
                |-------------------------------------------------------|--------------------|
                |               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
                |-------------------------------------------------------|--------------------|
                |               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
                |-------------------------------------------------------|--------------------|
                |                                              | lock:2 |    Marked for GC   |
                |-------------------------------------------------------|--------------------|
            64位虚拟机：
                |------------------------------------------------------------------------------|--------------------|
                |                                  Mark Word (64 bits)                         |       State        |
                |------------------------------------------------------------------------------|--------------------|
                | unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |       Normal       |
                |------------------------------------------------------------------------------|--------------------|
                | thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |
                |------------------------------------------------------------------------------|--------------------|
                |                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |
                |------------------------------------------------------------------------------|--------------------|
                |                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |
                |------------------------------------------------------------------------------|--------------------|
                |                                                                     | lock:2 |    Marked for GC   |
                |------------------------------------------------------------------------------|--------------------|

            Mark Word各部分含义如下:
                identity_hashcode：
                    对象的hashcode值，特别注意：这个值并不是在创建对象时就已经产生的，而是在第一次实际调用对象的hashcode()方法时才会计算对象的hashcode值，并设置咋对象的对象头中；在32位中占用25个bit，在64位中占用31个bit；
                age：
                    对象的分代年龄，新创建的对象该值为0，GC中，如果对象在Survivor区复制一次，该值加1，由于无论是32位还是64位，该值只有四个bit存储，因此，对象的分代年龄最大只有15；当对象的分代年龄到达阈值15之后，会晋升到老年代！
                biased_lock：
                    偏向锁标志位，表示当前对象是否启用偏向锁；仅占1个bit;为1时表示启用偏向锁，为0时表示没有使用偏向锁；
                lock：
                    锁标志位；占据2个bit,lock和biased_lock组合实现不同的锁类型：
                    biased_lock 	lock 	状态
                        0 	         01 	无锁
                        1 	         01 	偏向锁
                        0 	         00 	轻量级锁
                        0 	         10 	重量级锁
                        0 	         11 	GC标记
                thread:
                    持有偏向锁的线程id；
                
                ptr_to_lock_record：
                    指向栈中锁记录的指针；
                ptr_to_heavyweight_monitor：
                    指向管程Monitor的指针；
        类型指针(Class Pointer)：
            类型指针指向当前对象所属的类元数据；JVM通过该指针确定当前对象是哪一个类的实例；该指针在32位JVM中占用32个bit，在64位JVM中占用64个bit；
            但是对于64位的JVM可以通过+UseCompressedOops参数开启指针压缩，-UseCompressedOops参数禁止指针压缩，开启指针压缩之后，64位虚拟机下类型指针同样只占用32个bit；
        
        数组长度：
            对于数组类型的对象，还需要在对象头中存储数组的长度，该部分占用内存空间的大小和虚拟机位数不同有所不同：32位虚拟机占用32个bit，64位虚拟机占用64个bit；如果启用指针压缩，那么64位虚拟机该部分长度同样为32个bit；

3.对象的类型：
    1.对象按照引用类型分为以下四种：
        1.强引用类型
        2.软引用类型
        3.弱引用类型
        4.虚引用类型
    2.在实际使用功能上，强、软、弱类型的引用提供了控制对象生存周期的能力，而虚引用除过提供控制对象生存周期的能力外，也提供了感知对象被回收的能力；
    3.强引用类型：
        1.通常以构造方法直接创建的对象都是强引用类型；如：
            Color color = new Color();
        2.强引用类型在垃圾回收中除非引用和对象断开才会被回收，否则直到抛出OOM也不会被回收；
    4.软引用类型：
        1.通过SoftReference包裹的对象称之为软引用类型；如：
            SoftReference<Color> soft = new SoftReference<Color>(new Color);
        2.如果内存不足时发生GC，但是GC完成之后内存依然不够，就会把软引用类型的对象回收掉；
    5.弱引用类型：
        1.通过WeakReference包裹的对象称之为弱引用类型，如：
            WeakReference<Color> weak = new WeakReference<Color>(new  Color());
        2.弱引用类型，只要发生GC，对象就会被回收；
    6.虚引用类型：
        1.通过PhantomReference包裹的对象称之为虚引用类型，如：
            PhantomReference<Color> phant = new PhantomReference<Color>(new Color());
        2.虚引用类型只要发生GC，对象就会被回收；

4.对象的创建流程：
    1.关于对象创建：
        1.对象创建的本质就是在堆内存中申请内存区域，并进行属性初始化的过程；
        2.由于对象内存的存储位置在线程共享的堆区，那么并发分配内存时将会由线程安全问题，JVM通过CAS或者TLAB来解决；
    2.流程：
        1.检查要创建对象的类是否已经加载至内存：
            虚拟机会先检查new关键字指令的参数能否在常量池中找到一个类的符号引用，并且检查该类是否已经完成加载流程；如果没有找到类的符号引用或者类没有完成类的加在流程，那么会先执行类的加在流程来加载要创建对象的类；
        2.计算对象占用内存空间的大小：
        对象占用内存空间的大小(简称对象大小)由三部分组成：对象头、对象的实例数据、因为步长而产生的对齐数据，这三部分的长度分别如下:
            1.对象头的长度是已经设计好的，长度32位或者64位；
            2.对象的实例数据在类加载完成之后，根据当前类中的实例属性信息以及超类中的实例属性信息即可确定；
            3.如果实例数据的长度不足步长的整数倍，那么还会添加对齐数据，使对象的长度为步长的整数倍；
        3.根据对象的大小分配内存空间：
            1.对象内存分配主要涉及两个问题：
                1.线程安全问题：
                    由于对象所处内存空间是共享的，那么多线程并发创建对象时将会由线程安全问题，JVM解决这个问题时有两种方式：
                    1.采用的CAS+自旋来解决，
                    2.JVM如果配置了允许使用TLAB机制的话，那么会为每一个线程分配一小块该线程的私有区域，这块区域只能由指定线程写入，所有线程可读，那么线程在这块区域分配内存空间的话不会出现并发安全问题；
                    3.可以通过参数XX：+/- UseTLAB选择是否使用TLAB机制；
                2.分配方式问题：
                    1.如果内存比较规整，那么可以把内存完全分为两部分：已使用区域和未使用区域，那么为对象分配内存实际上就变成了从未使用区域划分一段内存空间至已使用区域即可，效率很高，对象创建的吞吐量很高；
                    2.如果内存不规整，已使用区域和未使用区域交错在一起，那么在分配内存之前还需要先找到一块大小适合的内存空间，然后在这块内存上分配；效率相对第一种方式较差；
                    3.在实际jvm的实现中，会通过空闲列表和指针碰撞相结合的方式为对象分配内存空间，首先会通过空闲列表找到足够大的一段内存，然后通过指针碰撞的方式分配够当前对象需要的内存空间；
        4.内存空间格式化：
            将实例属性初始化为零值；不同数据类型零值如下：
            byte、short、int、long：0
                floot、double：0.0
                boolean：false
                char：0
                引用类型：null
                
        5.初始化对象头信息：
            包括初始化对象的hashcode值(第一次调用对象的hashcode()方法时才会真正生成)
            对象的偏向锁类型、锁标志位、GC分代年龄等信息以及类型指针信息；
           
        6.执行类的构造函数初始化对象：
            执行完第5步之后对象就已经创建完成，这一步是按照编码中对实例属性的赋值操作进行实例属性初始话：
                首先按照类的继承关系，从顶级父类到当前类依次执行实例属性赋值语句、实例代码块、构造方法；
            该步执行完成之后，一个可用的对象就算创建完成；

