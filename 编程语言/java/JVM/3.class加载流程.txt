1.类加载的各个阶段：
    1.加载->2.验证->3.准备->4.解析->5.初始化->6.使用->7.卸载
2.触发类加载时机：
    1.通过类的构造方法实例化一个对象；
    2.通过类读取/设置类的静态属性；
    3.通过类执行类的静态方法；
    4.调用接口的default方法；
    5.当前正在加载的类其父类还未加载，会先加载父类；
    6.执行主类的main方法时会先初始化主类；
3.不会触发类加载的时机：
    1.通过子类引用父类的静态字段，只会触发加载父类，不会触发加载子类；
    2.通过数组定义引用类，不会触发类的加载；

4.类不同加载阶段功能：
    1.类加载阶段：
        1.类加载阶段主要完成三个事情：
            1.查找该类的二进制流；
            2.将该类的二进制字节流从静态存储结构转换为方法区运行时数据结构；
            3.在内存中生成该类对应的Class对象，在Class对象中有一个软引用ReflectionData存储该类的元信息；
        2.注意点：
            1.虚拟机通过类的全限定名称查找类的二进制字节流，但并未规定必须从何处查找字节流，通常情况下都是从文件系统中查找，但是也可以来自网络、运行时动态生成；具体可以通过自定义类加载器实现；
            2.数组类型不会通过类加载器加载，而是在程序中动态构造出来的；
    2.验证阶段：
        1.验证阶段主要是验证加载的二进制流是否符合class文件规范，语法逻辑是否正确；防止对虚拟机造成安全隐患，是整个加载流程中最重要、耗时最长的阶段，但是并不是必须的阶段，如果能够信任加载的class文件一定是符合规范的，那么可以通过配置-Xverify:nont关闭验证，提高类加载效率；
        2.整体上验证四个内容：
            1.class文件格式的验证：主要包括：二进制流是否以魔数开头、主次版本号和当前虚拟机是否匹配，常量池中是否有不被支持的常量类型等；
            2.元数据验证：是指对字节码的语义进行分析，包括类、接口的定义是否符合语法规范等；
            3.字节码验证：对程序的流程语法进行验证，分析的对象时方法体；
            4.符号验证：当前类是否引用了被禁止访问的类、方法、字段等；
    3.准备阶段：
        1.在准备阶段，主要做的事情就是为静态属性分配内存空间，并初始化为对应数据类型的零值；
        2.静态属性的内存空间是在准备阶段分配的！静态属性的零值时在准备阶段赋值的；
        3.准备阶段只会为静态属性进行准备，不会为实例属性做准备，并且不会按照编码中的赋值语句对静态属性进行赋值；
        4.特别注意的是：如果静态属性前有final关键字，那么在编译阶段该属性的值就被固定保存了，然后在准备阶段吧编译阶段保存的值赋值给该静态属性；
    4.解析阶段：
        1.解析阶段主要做的事情是将符号引用替换为直接引用；
        2.类编译完成之后，类中访问的类、方法、字段全部都存储的是类、方法、字段的名称和描述信息，而不是对应的内存访问入口地址；
        3.在解析阶段，会把这些表示类、方法、字段访问入口的字符串全部替换为真正的内存入口地址；这个过程就是符号引用替换为直接引用的过程；
    5.初始化阶段：
        1.初始化阶段主要完成的事情就是为静态属性按照编码进行赋值；
        2.赋值时按照类的继承结构，从顶级父类向当前类执行的顺序，先执行静态属性的直接赋值语句，后执行静态代码块；
        3.多线程环境下，虚拟机会保证类初始化的线程安全，同一时刻只会有一个线程执行类静态属性的初始化操作；
5.关于类加载器：
    1.执行类加载功能的程序称之为类加载器；类加载器除过加载类以外，还与类的全限定名称共同确定类的唯一性；即：类在系统中的唯一性是通过类加载器和类的全限定名称共同决定的；
    2.类加载器主要分为三大类：
        1.启动类加载器：负责加载java的核心类库；
        2.扩展类加载器：负责加载java中的扩展类库；
        3.系统类加载器：负责加载用户自定义的相关类库；
    3.双亲委派模型：
        1.在一个系统中，类的唯一性非常重要，也就是说一个类只能被加载一次，如果被加载多次，那程序里面将无法确定具体要使用的类型；
        2.双亲委派模型是保证类只会加载一次的重要措施；
        3.双亲委派模型具体内容如下：
            1.当前类加载器加载类时会将需要加载的类委派给其父类加载器加载，父类加载器也会将加载请求继续委托给其父类加载器加载，以此类推，直到委托给启动类加载器；而父类加载器接收到加载请求之后，会检测自己是否能够加载这个类，不能加载的话又会反向委托给其子类加载器，直到能够加载该类的加载器，类加载器加载类之前也会先检测一下类是否已经被加载，如果没有被加载才加载，如果已经被加载那么将不会在继续加载；通过这种机制保证类在系统中的唯一性；
        4.特别注意的是父子类加载器仅仅只是加载职责上的父子关系，并不是继承结构上的父子关系；
        