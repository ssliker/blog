1.JVM内存结构：
    JVM内存结构又叫做JVM运行时数据区，分为5大部分：
    1.线程私有部分：程序计数器、虚拟机栈、本地方法栈
    2.线程共享部分：堆内存、方法区

2.程序计数器特征：
    1.特征：
        1.线程私有，不共享，每个线程内部都有一个程序计数器；
        2.生命周期和线程相同，线程创建之初就会创建程序计数器，线程结束，其占用的程序计数器内存空间也会被释放；
        3.仅存储线程执行位置，所以占用内存空间很小，也是JVM内存结构中唯一一块不会发生内存溢出的区域；
    2.功能：
        1.记录当前线程执行指令的位置，就是程序的控制流指示器，帮助线程能够按照正确的指令顺序执行指令；程序中的跳转、分支、循环、异常处理都需借助程序计数器完成；
    3.取值：
        1.对于java方法：存储的是指令距离首条指令的偏移量；
        2.对于native方法：其值固定为undefined；
    4.原理：
        1.为何需要程序计数器
            由于cpu会一直切换线程，那么线程被切换出去时需要记录下当前线程的指令执行位置，在线程切换回来继续执行时需要根据之前记录的位置继续向下执行，是程序正确执行指令的必备条件；
        2.为何要线程私有：
            系统中同时会有多个线程在执行指令，每个线程都会有自己的执行进度，程序计数器对于线程私有的话可以保证线程间的程序计数器互相独立，互不干扰，每个线程都能正确的按照自己的进度执行；
        3.为何执行本地方法时程序计数器为undefined?
            本地方法不是java实现的，不需要转换为java字节码指令，本地方法的执行进度由系统存储，无需在java线程内部再保持这部分信息；

3.虚拟机栈：
    1.特点：
        1.线程私有，不共享，每个线程内部都会有一个虚拟机栈；
        2.虚拟机栈生命周期和线程生命周期相同，随着线程创建而分配，随着线程结束而销毁；
        3.虚拟机栈会有两个维度上的限制，如果超过限制将会抛出虚拟机异常信息：
            1.栈深度：即一个虚拟机栈中可以存放栈帧的数量，超过之后会包StackOverFlowError异常；
            2.栈内存：即一个虚拟机栈可用内存虽然是可以动态扩展的，但是扩展时如果无法申请到足够内存时就会抛出OOM异常；
        4.虚拟机栈不存在垃圾回收的问题，调用方法时产生栈帧压入栈中，方法返回时将栈帧出栈；
    2.功能：
        1.存储当前线程中方法的调用信息，包括方法的调用链、方法内的局部变量、方法出口信息等；
    
    3.设置虚拟机栈空间大小：
        1.通过jvm参数-Xss设置栈空间大小；
    
    4.原理：
        1.虚拟机栈由栈帧组成，每调用一个方法就会产生一个栈帧，并压入栈顶部，当方法调用return返回或者发生异常返回时，将上一个方法的返回结果传递给下一个栈帧，并将当前顶部栈帧出栈；
        2.而每一个栈帧则由局部变量表、操作数栈、动态链接、方法出口信息组成；
        3.对于局部变量表：
            1.存储着当前方法中创建的局部变量；
            2.由于方法中的局部变量存储在线程私有的线程栈中，不被其他线程共享，因此局部变量一定是线程安全的；
            3.局部变量表的大小在编译期间就可以确定，并保存在方法的属性中，方法运行期间，局部变量表的大小不会被改变；
            4.局部变量表中存储变量的基本单位是槽，有以下几个特征：
                1.32位以内的变量只占用一个槽，64位的变量会占用2个连续的槽；
                2.槽是有顺序的，顺序从0开始，方法中的局部变量会按照定义顺序依次复制到槽中；可以通过索引访问到槽中存储的局部变量；
                3.如果当前栈帧对应的是一个实例方法或者构造方法，那么第1个槽位固定放置其所属实例的引用this,然后局部变量按照定义顺序依次复制到槽位中，对于静态方法首个槽位就开始放置局部变量；也正是这个原因，实例方法中可以直接使用this，而静态方法中不可以使用this关键字；
                4.槽位是可以重复使用的，因为局部变量有作用域，如果变量已经出了其作用域，那么在其之后新定义的变量就可能覆盖过期局部变量的槽位；
                5.局部变量表中直接或者间接引用的对象被当做根节点对象，不会被回收，而且作为标记其他对象的起始对象；
        4.操作数栈：
            1.操作数栈是一个先进先出的栈，用来存储当前方法中的中间计算结果，也是计算过程中变量的临时存储空间；
            2.操作数栈的深度在编译期间就已经确定好了，保存在方法的属性中；32位数据占用一个栈容量，64位数据占用两个栈容量；
            3.操作数栈并不像局部变量表一样是通过索引访问的，而是简单的出栈和入栈；
        5.动态链接：
            1.动态链接是指向运行时常量池的引用；
            2.在java源文件被编译到字节码文件中时，所有的变量和方法引用都是作为符号引用保存在class文件的常量池中的，而不是存储着方法或者变量在内存中的入口地址，那么方法在访问变量/其他方法时是需要把这个符号转换为内存中的入口地址才能访问到的，那么就需要根据动态链接获取到方法、变量对应的实际地址；即动态链接的作用就是能够将符号引用转换为直接引用；
        6.方法出口信息：
            1.用来存放调用当前方法的指令地址；当方法执行结束之后根据当方法出口信息返回到正确的指令位置；
            2.一个方法的结束有两种方式：
                1.正常执行完成；
                2.发生异常，中途突出；
            3.无论方法以何种方式退出，只要退出就必须返回到调用该方法的位置；只是正常执行完成的会把当前方法的执行结果返回给上一层栈帧，异常退出的则不会吧结果返回给上一层；
4.本地方法栈：
    1.本地方法栈用来管理本地方法的调用信息；
    2.本地方法栈也是线程私有的；
    3.本地方法栈也有栈深度和内存大小的限制；
    4.无论是本地方法栈还是虚拟机栈都属于运行时存储区域，用来管理线程本身的运行信息；
5.堆内存：
    1.特点：
        1.JVM中占用内存空间最大的一块区域，主要存放各个线程中创建的实例；
        2.所有线程共享这一块区域；
    2.大小：
        1.可以通过JVM参数：-Xms和-Xmx来设置，-Xms用来设置起始内存，-Xmx用来设置最大许可使用内存；
        2.默认情况下，JVM的起始内存是物理内存的64/1，最大内存是物理内存的4/1
    3.组成：
        1.整体分类：
            为了高效的进行垃圾回收，JVM按照分代理论，将堆在逻辑上分为三块区域：
            1.新生代(年轻代)、2.老年代、3.元空间(JDK1.8之前叫做永久代)
            2.为何要进行分代：
                1.分代的目的在于提高垃圾回收效率，垃圾回收是指对对象占用的内存空间进行回收；
                2.如果没有分代理论，那么每次垃圾回收都需要遍历所有的对象，检测是否已经失去引用然后回收，这个过程非常耗时，代价很大！
                3.在分代理论下，系统中的对象其实是具有不同生命周期的，有的对象可能只使用一次就废弃了，有的对象可能会持续到整个进程结束，而且越是新创建的对象越可能早的被废弃；
                4.基于分代理论可以为不同的对象设置不同的分代年龄，并保存在对象头中，每经过一次GC，其分代年龄+1，如果经过15次GC之后仍旧存活的对象可以单独存储，不再进行回收，每次仅回收分代年龄低的对象，这样垃圾回收时需要处理的对象会更少，效率更高；
        2.关于新生代：
            1.新生代又称为年轻代，主要存储新创建的对象以及分代年龄不足15的对象；
            2.新生代为了高效的进行垃圾回收，又分为：Eden区域，和survivor区域，而survivor区域被进一步分成from区域和to区域；整体比例：Eden:from:to=8:1:1
            3.大多数新建对象都会在Eden区域存储，当Eden区域占满时会执行一次MinorGC，此时会将Eden区域存活的对象全部移动到to区域中；而from区域中的对象根据其分代年龄决定是继续移动到to区域还是直接移动到老年代；
            4.此次GC之后，对象的分代年龄会+1，并且移动完成之后开始清理已经不再存活的对象，然后将to区域重新标记为from区域，之前的from区域标记为to区域；如果to区域的大小不足以存放还存活的对象，将会利用老年代的部分区域承担存储；
        3.关于老年代：
            1.老年代主要存储经过多次GC还存活的对象，以及大对象；
            2.大对象之所以要放在老年代主要是为了避免对象在Eden和survivor之间来回拷贝导致性能下降；
            3.老年代不足时将会触发Major GC，如果Major GC只会，仍然没有足够的空间，那么将会抛出OOM异常；
6.关于方法区：
    1.特征：
        1.方法区被所有线程共享；
        2.方法区中主要存储class、接口、方法、静态属性以及运行时常量池(运行时常量池中主要放置字面量和一些符号引用)等信息；
        3.方法区大小可以是固定大小，也可以选择可扩展，如果方法区中加载的类过多，导致超出内存，方法区中同样抛出OOM异常；
        4.方法区是逻辑上的概念，永久代/元空间是对存储空间进行分割的概念，方法区一般在永久代/元空间上分配内存；
7.其他Q&A:
    1.为何需要常量池？
        主要目的在于减小字节码体积，实现字面量复用；java源文件中的类、接口、编译后产生一个字节码文件，一个字节码文件中经常会需要存储一些字面量，有的字面量甚至会比较大以至于不能直接存在字节码里面，如果存在常量池中，而字节码只保存对该字面量的符号引用那么字节码的体积会小很多；而且常量池的存在，尤其如字符串常量池，可以实现字符串的复用，避免需要分配过多的内存空间；
    
    2.方法区垃圾回收都回收哪些内容？
        方法区垃圾回收主要包括：常量池中废弃的常量和不再使用的类；

    3.类何时会被回收？
        1.类不再被使用时将会回收，满足不再被使用的条件有三个：
            1.该类的所有实例都被回收；
            2.加载该类的类加载器已经被回收；
            3.该类对应的Class对象没有在任何地方被引用；
    4.符号引用通常有哪些？
        1.类和接口的全限定名称
        2.字段的名称和描述符
        3.方法的名称和描述符
    5.垃圾回收算法有哪些？
        1，引用计数算法，每增加一次引用引用计数+1，减少一次引用，引用计数减一，当引用计数减到0时，表明该对象可以被回收；但是引用计数算法无法解决循环依赖的问题；
        2.标记-清除算法：先标记后清除，会出现内存碎片的情况；
        3.复制算法：先标记后复制再整体清除，效率低，空间利用率也低，但是不会出现内存碎片的情况；
        4.标记-整理算法：先标记出需要清除的对象，然后让存活的对象向一边移动，然后清除边界之外的内存空间；效率低，但是不会出现内存碎片的情况；
        新生代一般使用标记-复制算法，老年代一般使用标记清除和标记整理算法；
    6.方法区会有垃圾回收吗？
        会有，方法区垃圾回收主要包括两个方面：常量池中的常量、需要被卸载的类；
    7.作为GCroots的对象一般有哪些？
        1.静态属性引用的对象
        2.常量池中常量引用的对象
        3.java虚拟机栈中栈帧中定义的对象，即方法的局部变量引用的对象；
        4.本地方法栈的栈帧中引用的对象；
    

     
        


        