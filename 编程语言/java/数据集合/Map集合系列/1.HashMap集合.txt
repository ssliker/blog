1.HashMap特征：
    1.HashMap用来存储k-v类型的键值对数据；
    2.HashMap允许接收键为null和值为null的k-v数据；但是在实际使用时尽量避免出现null类型的键和null类型的值被添加进去；
    3.HashMap不会维护存储在其中的k-v顺序，在遍历HashMap时，并不会按照key的添加顺序或者key的大小顺序遍历；
    4.HashMap本身没有做任何线程同步处理，并非线程安全集合，不可以直接作为多线程环境下的共享变量；

2.HashMap继承结构：
    1.继承结构图
        Map(I)
            |--AbstractMap(AC)
        |---|--HashMap(C)
    2.关于继承关系：
        1.HashMap同时继承AbstractMap抽象类和Map接口。而AbstractMap则直接继承自Map接口；
        2.本质上HashMap直接继承自AbstractMap即可，对于既继承AbtractMap又继承Map接口本质上属于设计缺陷！

3.HashMap功能：
    1.新增k-v：
        put(k, v)
        功能描述：
            1.向HashMap中添加一个k-v；如果k已存在，则直接使用新值覆盖旧值；
        putIfAbsent(k, v)
        功能描述：  
            1.向HashMap中添加一个k-v；但如果k已存在，则不添加，直接返回；
        putAll(Map m)
        功能描述：
            1.向HashMap中添加一个已有的Map类型集合；
    
    2.获取k-v：
        get(k)
        功能描述：
            1.从HashMap中获取键为k的值；
            2.如果k不存在则返回null；
        getOrDefault(k,default)
        功能描述：
            1.从HashMap中获取键为k的值；
            2.如果k不存在则返回default；
    
    3.删除k-v：
        remove(k)
        功能描述：
            1.从HashMap中删除键为k的键值对；
            2.如果k不存在则不作任何处理；
        remove(k,v)
        功能描述：
            1.从HashMap中删除键为k,且值为v的键值对；
            2.如果k不存在或v未匹配到则不作任何处理；
    4.检测k和v是否存在：
        containsKey(k)：检测k是否存在
        containsValue(v)：检测v是否存
    5.替换k-v:
        replace(k,v)：
        功能描述：
            1.将键为k对应的值替换为v；如果没有匹配到将不作任何处理；
        replace(k,oldv,newv)：
        功能描述：
            1.将键为k，且值为oldv的键值对值替换为newv；如果没有匹配到k或者oldv将不作任何处理；
    6.其他方法：
        size()：返回当前map中键值对的个数；
        isEmpty()：检测当前map是否为空；
        clear()：清空当前map；
        keySet()：返回map中key的set集合：Set<String>；
        values()：返回map中的value集合：Collection<String>；
        entrySet()：返回map中节点的集合：Set<Map.Entry<K,V>>；
    
    7.聚合汇总方法：
        compute()：
        功能描述：
            1.函数式处理方法，对于输入的k，将会执行针对k和v的处理逻辑，接受一个返回值作为k的新v；
        使用方法：
            compute(ikey,(k,v)->{
                // k->ikey
                // v->map.get(k)
                return newv;
            })
        注意事项：
            1.k如果在map中不存在时，v将会数null，因此在该方法中必须手动处理v为null的情况；

        computeIfAbsent():
        功能描述：
            1.函数式处理方法，对于输入的k，如果在map中不存在时，才会执行添加的函数式处理逻辑；接受一个返回值作为该k的新v；
        使用方法：
            computeIfAbsent(ikey,(k)->{
                // k->ikey
                return newv;
            })
        注意事项：
            1.只有ikey在map中不存在时才会执行后面的函数式逻辑；
        
        computeIfPresent():
        功能描述：
            1.函数式处理方法，对于输入的k，如果在map中存在时，才会执行添加的函数式处理逻辑；接受一个返回值作为该k的新v；
        使用方法：
            computeIfAbsent(ikey,(k,v)->{
                // k->ikey
                return newv;
            })
        注意事项：
            1.只有ikey在map不存在时才会执行后面的函数式逻辑；和computeIfAbsent相反； 
        merge()
    8.关于entryset()方法：
        1.该方法返回一个set集合，元素类型为Map.Entry<K, V>，Map.Entry为Map中的静态内部类，一个Map.Entry中存储一个键值对的k和v；
        2.通过Map.Entry类型的实例对象即可获取该键值对的k和v：getKey()、getValue()；同时也可以设置该节点的value：setValue();

4.HashMap的遍历：

5.HashMap实现原理：
    1.HashMap底层数据结构：
        1.JDK1.8底层使用数组+(链表/红黑树)实现；数组作为hash桶，用来确定一个元素的桶位；链表和红黑树用来解决hash冲突的问题；
    2.HashMap增加元素过程：
        插入方法为put()方法，其底层则调用了putVal()方法，具体插入操作均在putVal()方法中实现；具体流程如下：
        1.首先检测表示hash桶的数组是否已经初始化，如果数组长度为0或者数组为null，则先调用resize方法进行扩容；
        2.计算key的hash值，并使用key的hash值与数组进行取余操作，确定key-value应该放入hash桶的位置，即数组的下标；
        3.检测该数组下标对应位置是否已经有值，如果没有值则直接将该k-v放入该位置，如果有值则进行一下判断：
            1.检测该位置元素hash值与key值是否与当前待插入元素相同，如果相同，则直接使用该新值覆盖旧值；
            2.如果1没有匹配，那么继续检测当前位置节点是否是TreeNode类型，即当前位置出现hash冲突的元素是否已经树化为红黑树，如果是则将该k-v封装为一个TreeNode添加至红黑树中；
            3.如果2没有匹配，那么表示当前位置出现hash冲突的元素是通过链表来组织的，则开始遍历当前位置的链表：
                1.遍历过程中，如果出现hash值与key值都和当前待插入元素相同的元素，则直接使用新值覆盖旧值；
                2.如果链表遍历完成之后，则将该待插入元素封装为一个Node节点添加至链表尾部；然后检测当前链表中元素个数是否大于树化阈值-1，如果满足树化条件，则进行树化；
        4.调用钩子方法afterNodeAccess()，在HashMap中该方法没有具体实现，无实际功能；
        5.modCount加1，表示该Map已经被修改，方便遍历该Map的线程快速失败；
        6.表示Map元素总数的size加1，并与扩容与之进行比较，如果size已经大于扩容阈值，则调用resize方法进行扩容；
        7.调用afterNodeInsertion()钩子方法，在HashMap中该方法没有具体实现，无实际功能；
    3.HashMap扩容过程：
        HashMap的扩容过程在resize()方法中实现；具体流程如下：
            1.检测旧数组长度是否已经大于0，如果已经大于0则说明已经至少扩容过一次，将继续进行一下检查：
                1.如果旧数组容量已经大于等于数组最大容量MAXIMUM_CAPACITY(2^30)时，直接将扩容阈值设置为Integer.MAX_VALUE(2^32)，然后直接返回旧数组容量，即不再扩容；
                2.如果旧数组容量小于数组最大容量，则将新容量和新扩容阈值设置为旧容量和旧阈值的2倍；
            2.如果当前旧数组的长度为0，并且扩容阈值大于0，则表示当前map还未进行扩容，并且手动制定了初始容量；则将扩容阈值大小赋值给数组容量；
            3.如果当前旧数组长度为0，并且扩容阈值为0，则说明当前map还未进行初始化，并且未指定初始容量和扩容阈值，则使用默认长度作为新数组长度，并使用默认扩容因子与默认数组长度计算新的扩容阈值；
            4.检测新扩容阈值是否为0，如果为0，则使用扩容因子和新的数组容量计算得出扩容阈值并赋值给新的扩容阈值；正常情况下，只有首次初始化，并且手动指定初始容量时才需要计算新的扩容阈值；
            5.使用新的数组容量值创建新的数组，并遍历旧数组，将旧数组中的元素重新计算桶位并添加新数组中；
                1.如果当前桶位只有一个元素，则重新计算该元素的位置，并重新设置即可；
                2.如果当前桶位已经树化为红黑树，那么拆分红黑树，必要时退化为链表，并对每一个元素重新分配位置；
                3.如果当前位置存储的是一个链表，则遍历链表，重新计算并挪动元素位置；
    4.HashMap中的细节：
        1.HashMap为何要同时使用链表和红黑树解决hash冲突？
        2.HashMap中各项默认值？
        3.HashMap树化阈值？
        4.HashMap中的树化阈值为何是8？为何树化时要减1，而非树化时要加1？
        5.为何必须在元素数量超过64时才会树化？
        6.HashMap中计算keyhash值得细节？
        7.HashMap中数组长度为何必须是2的次幂？
        8.HashMap扩容时为何要扩容为旧容量的2倍？
        9.HashMap中扩容因子为何是0.75？
        10关于HashMap的快速失败机制？

        
        



    
    
        
    