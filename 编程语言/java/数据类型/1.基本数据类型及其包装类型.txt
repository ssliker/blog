1.关于基本数据类型、包装类型和大数类型：
    java中提供了整型、浮点型、布尔类型、字符类型四种基本数据类型，以及四种基本数据类型对应的包装类型；
    1.基本数据类型：
        1.类型值：
            整型：根据占用内存大小又分为以下四种
                |--byte：大小：1个字节；8位；范围：-128~127(2^8~2^8-1)
                |--short：大小：2个字节；16位；范围：-32768~32767(2^16~2^16-1)
                |--int：大小：4个字节；32位；范围：-2^32~2^32-1(-2147483648~2147483647)
                |--long：大小：8个字节；64位；范围：-2^^64~2^64-1
            
            浮点型：根据精度不同分为以下两种：
                |--float：大小：4个字节；32位；精度：7位；单精度类型
                |--double：大小：8个字节；64位；精度：15位；双精度类型
            
            字符类型：
                |--char：大小：2个字节；16位；范围：-32768~32767(2^16~2^16-1)
            
            布尔类型：
                |--boolean：大小1个字节；8位；取值：true/false
        
        2.关于基本数据类型：
            1.基本数据类型仅仅表示一种数据类型，不具备任何面向对象特征；
            2.由于基本数据类型不具备任何面向对象特征，因此在使用基本类型时要注意两个事项：
                1.基本类型不能使用在需要引用类型的场景：如当前变量需要容纳null、当前数据类型在泛型场景中；
                2.其运算方式和引用类型的运算有较大差异：如算术运算、比较运算；
            3.通常情况下建议局部变量(包括形参)使用基本数据类型；
    
    2.包装类型：
        1.类型值：
            整型包装类型：和整型基本数据类型相对，有以下四种：
                |--Byte：表示byte类型的包装类型；
                |--Short：表示short类型的包装类型；
                |--Integer：表示int类型的包装类型；
                |--Long：表示long类型的包装类型；

            浮点型包装类型：和浮点型基本数据类型相对，有以下两种：
                |--Float：表示float类型的包装类型
                |--Double：表示double类型的包装类型

            字符型包装类型：
                |--Short：表示short类型的包装类型；
            
            布尔包装类型：
                |--Boolean：表示boolean类型的包装类型；
        
        2.关于包装类型：
            1.每一种包装类型都和基本类型相对应，属于引用类型，让基本类型有了面向对象的特征，能够让基本数据类型方便的用在只接受引用类型的场景中；
            2.包装类型其本质上是对基本数据类型以对象属性的方式进行了包装；虽然其属于引用类型，但是同时也可以直接代替基本类型使用；
    
    3.关于大数类型：
         java中，由于每一种数据类型占用的字节数是固定的，因此无论是整数类型还是浮点数类型，其能够表示的数字大小都是有上限和下限的，但是在实际中，则可能需要处理超过该整型/浮点型上下限的数字，为此java中提供了以下两种大数类型：
            |--BigInteger来表示更大的整数
            |--BigDecimal来表示更大的浮点数；

2.关于数据类型与字面量：
    1.数据类型本质上是一种标记，用来标识某一个数据的类型特征，本身并不具有任何值或者内容；
    2.字面量是指某一种数据类型的确切数据值；

3.基本数据类型详解：
    1.关于整数数据类型特征：
        1.关于整数类型表示范围：
            1.整数数据类型取值范围包括：正整数、0、负整数；

        2.关于整数字面量：
            1.java中直接给定的int范围内的整数字面量默认是int类型；
            2.如果给定的整数字面量在byte、short类型的大小范围内，并且赋值给byte、short类型的变量时，该字面量会被当做byte、short类型对待；
            3.如果给定的整数字面量大于int类型表示的大小范围，那么该整数字面量只能赋值给long型变量，并且该整数字面量末尾要带上L或者l后缀，表示该整数字面量是long型的；
            4.如果给定的整数字面量在byte、short类型的大小范围内，并且赋值给byte、short类型的变量时，该字面量会被当做byte、short类型对待；
            注意：
                1.字面量赋值给变量时必须注意是否超过该变量类型所容纳的范围，直接赋值发生溢出之后将直接报错；
                2.表达式计算所得结果赋值给变量时要注意是否会发生溢出，发生溢出之后将会从该变量类型数值范围的最小值开始从新计数；
        
        3.关于整数进制：
            1.java支持以二进制、八进制、十进制、十六进制的格式表示整数字面量；
            2.java中不同进制的整数字面量格式：
                1：二进制以0b或者0B作为前缀，由0和1组成；
                2：八进制以0作为前缀，由0~7组成；
                3：十进制无任何前缀，由0~9组成；缀，由0~9组成；
                4：十六进制以0x或者0X作为前缀，由0~9和a~f(A~F)组成；
            3.java中不同进制的转换：
                1.十进制转其他进制：
                    十进制转二进制字符串：Integer.toBinaryString(num)
                    十进制转八进制字符串：Integer.toOctalString(num)
                    十进制转十六进制字符串：Integer.toHexString(num)
                    十进制转r进制字符串：Integer.toString(进制数,num)
                    注意：
                        1.num只能是十进制整数；否则将发生异常；
                2.其他进制字符串转十进制：
                    Integer.parseInt(String num, int radix)
                    注意：
                        1.num只能是其他进制的字符串，且不能带进制前缀，否则将发生异常；
                        2.redis是十进制整数，表示num的原始进制；

            4.进制转换注意事项：
                1.进制转换只能以十进制作为中间进制转换；
                2.进制转换必须要处理转换出错的异常情况；
    
    2.浮点数类型：
        1.浮点数精度：
            1.浮点数在实际存储时采用除2取余法计算得到对应的二进制数值，在遇到无法被2整除的情况下将会产生循环小数，但是内存空间有限，必须对小数部分进行截取并进行四舍五入处理，小数部分被截取的位数称为浮点数的精度，同时因为小数部分的截取和四舍五入也会导致实际存储的小数和表示的小数不同；
            2.java中定义了两种不同精度的浮点数类型：float和double；
            3.float称为低精度类型，其中float精度只有7位；小数位数超过7位的浮点数将会从第7位开始截取并进行四舍五入处理；
            4.double称为高精度类型，其中double的精度有16位；小数位数超过16位的浮点数将会从第16位开始截取病进行四舍五入处理；
        
        2.浮点数字面量：
            1.java中默认小数都是double类型的浮点数，因此直接将浮点数赋值给float类型的变量将会报错；
            2.在将浮点数赋值给float类型的变量时，数字后面必须携带f或者F后缀；
            3.浮点数字面量的表示形式有两种：1.通过小数形式：1.23；2.通过科学计数法表示：0.232；    
            4.java中特殊的浮点数字面量：POSITIVE_INFINITY(正无穷大)、NEGATIVE_INFINITY(负无穷大)、NAN(非数)；
        
        3.关于正无穷、负无穷、非数；
            1.正浮点数除以0，得到正无穷大，负浮点数除以0得到负无穷大，对负数进行开方运算、0.0除以0.0或者改变量值不是数字类型将会成为NAN；特别注意：只有正负浮点数除以0才会是正负无穷大，整数除以0将会报除0异常；
            2.正无穷永远等于正无穷，负无穷永远等于负无穷，但是非数和任何值都不相等，包括和自己都不相等；
    
    3.布尔类型：
        1.布尔类型字面量：
            1.布尔类型只有固定的两个字面量：true和false；
            2.注意布尔值得书写，必须是全小写的true和false，其余字符都是非法字符；
        
        2.布尔值的使用：
            1.布尔值通常都是使用在条件表达式中，用来判断条件是否满足的；
            2.java在条件表达式中并不会将其他数据类型自动转换为布尔值，比如0、NAN、空集合、空字符串等；条件表达式只接受一个布尔值；
        
    4.字符类型：
        1.关于字符类型：
            1.字符类型使用char表示；
            2.字符类型在内存中占用2个字节；因此其职能表示65535个字符；
            3.java中使用unicode字符集，并使用UTF8编码，unicode中码值超过65535的字符将会使用2个char表示，即四个字节表示一个字符；
        
        2.关于字符字面量：
            1.字符字面量包括两种：普通字符、转义字符；
            2.普通字符表示字符集中的可打印字符；即用''包裹的字符：'a'、'b'、'+'等；
            3.转义字符表示字符集中的非打印字符，如：'\r','\n','\t','\v','\\','\'','\"','\b'等；
            4.字符在内存中实际存储的是字符在字符集中对应的码值，即小于65535的一个整数，因此可以直接使用一个Short范围内的整数表示一个字符字面量；
        
        3.关于字符集和字符编码：
    
2.包装类型：
    由于java是一个面向对象的编程语言，但是基本数据类型并不具备任何面向对象的特征，因此在某些只能接受引用类型的场景下将无法使用，如泛型、反射中只能使用包装类型；
    1.包装类型的实现：
        1.包装类型本质上是一个普通的对象，只是在该对象中定义了一个value属性来存储该对象表示的数值；每一个包装类型变量表示的数值就是该value属性的值；
        2.java对包装类型做了缓存优化，在程序启动时，jvm会提前创建若干个数值对应的包装类型对象，具体范围如下：
            1.对于Short、Integer、Long：
                jvm会提前创建好数值大小范围在[-128,128]之间的包装对象；
            2.对于Character：
                jvm会提前创建好码值大小范围在[0,128]之间的包装对象；
            3.对于Boolean：
                系统会提前创建好true和false值；
            4.对于Float和Double：
                jvm并不会提前创建这两种类型数值对应的包装对象，因为在任意两个浮点数值之间有无数非值，无法进行有效的优化；
            如果包装对象的值在上述jvm提前创建好的范围时，无论创建多少次，该值的包装对象都引用的同一个包装对象，如:
                Integer a = 12;
                Integer b = 12;
                if (a == b)：true；
    2.基本类型和包装类型的转换：
        1.基本类型转换为包装类型称为装箱；包装类型转换为基本类型称为拆箱；
        2.装箱和拆箱有两种方式：
            1.手动装箱和拆箱：
                装箱：new 包装类(数据值)
                    说明：
                        1：包装类即为上述包装类型；
                        2：装箱之后将得到引用类型的数据；
                拆箱：包装类型数据.xxxValue()
                    说明：
                        1：xxxValue，指不同数据类型，如：intValue()、floatValue()
                        2：拆箱之后将得到基本类型的数据；
            2.自动装箱和拆箱：
                1.在JDK1.5之后，jvm能够自动进行装箱和拆箱；因此带来以下便利：
                    1.可以将基本数据类型的值直接赋值给包装类型的变量；
                    2.可以将包装类型的值直接赋值给基本类型的变量；
                    3.包装类型可以和基本类型直接进行运算；
        3.关于自动装箱和拆箱的注意事项：
            1.关于自动拆箱：本质上仍然调用包装对象的xxxValue方法获取该包装对象的value属性值；因此在自动拆箱或者手动拆箱时，一定且必须要先验证该包装对象是否为null；

            2.关于自动装箱：本质上仍然是new一个包装类对象，而由于jvm对包装类的优化，在创建一个包装对象时，如果该包装对象的值已经在缓存范围内，那么将不会创建一个新的包装对象，而是直接返回已经创建好的包装对象，如果该包装对象的值不在缓存范围内，那么每次创建包装对象都是创建一个新的包装对象；
    3.包装类型提供的API：
        1.实例方法：
            1.大小比较：
                1.由于包装类型是引用类型，每一个包装类型都重写了compareTo方法，因此禁止使用>、>=、<、<+进行大小比较，而是使用compareTo()方法进行大小比较；
            2.等值比较：
                1.由于jvm对包装类型有优化，因此禁止使用==或者!=来进行包装类型的等值比较；而是使用equals()方法进行等值比较；
            3.返回基本类型数据：
                1.包装类型中通过value属性存储具体的数值，value属性的呗private final修饰，因此不能直接访问value属性获取具体数值；
                2.每一个包装类都提供了xxxVlaue()方法来返回该包装对象表示的数值；
        
        2.静态方法：
            1.静态属性：
                1.当前类型最大值：MAX_VALUE
                2.当前类型最小值：MIN_VALUE
            
            2.创建包装类对象：valueOf()
                1.对于包装类型对象，不仅仅可以通过构造方法创建，同时也可以通过静态方法valueOf()创建：valueOf()；
                2.valueOf()方法有三种重载形式，其参数可以为数字、纯数字字符串、指定进制的纯数字字符串；
                3.该方法返回对应包装类型的实例对象；
                4.使用该方法时需要处理转换异常，且待转换值不能为null；
            
            3.获取基本类型数据：
                1.通过静态方法：parseXxxx()即可将一个纯数字字符串转换为该包装类型对应的基本类型数据；
                2.该方法有两种重载形式：其参数可以为纯数字字符串、指定进制的纯数字字符串；
                3.使用该方法时需要注意处理转换异常，且待转化值不能为null；

            **预留问题4.其他静态方法

3.大数据类型：
    1.关于BigInteger和BigDecimal：
        1.BigInteger和BigDecimal本质上都是通过字符串来实现大数字的存储和表示，同时因为其是通过字符串实现的，不再受到整数类型和浮点数类型固定字节大小限制，可以表示任意大小的数字；
        2.虽然大数不再受到整数类型和浮点数类型固定字节的限制，但是由于其本质上是通过字符串实现，因此其数字位数受到jdk中字符串长度的限制，并且由于字符串在编译期和运行期长度限制并不同，因此BigInteger和BigDecimal编译期和运行期所能够表示的数字位数也不相同；
        3.BigInteger和BigDecimal虽然都表示一个数字，但是并不能和普通的整数类型或者浮点数类型同时参与运算；只能和同种类型的大数进行运算，并且只能使用jdk为大数类型增加的运算方法，不能直接使用+、-、*、/等基本运算方式，
        4.由于BigInteger和BigDecimal是通过建立对象来实现的，因此不能直接使用>、>=、<、<=、==、!=来直接比较数字大小以及是否相等，应该通过引用类型比较大小的方式，调用compare方法进行比较；
    
    2.关于BigInteger:
        1.BigInteger的创建：
            1.通过构造方法创建：
                BigInteger bigInteger = new BigInteger();
            备注：该构造方法有多种重载形式，常用的包括String和long类型的参数，但是实际使用时推荐使用String类型的参数；
            **预留问题：其他构造方法参数形式以及使用方式；

            2.通过valueOf()方法创建：
                BigInteger.valueOf(double value);
            备注：该方法只接受一个double类型的参数；

        2.BigInteger的运算：
            BigInteger不能直接使用jdk提供的运算符号进行运算；只能使用BigInteger提供的运算方法进行运算：
            1.加减乘除运算；
                加法运算：add(BigInteger big)
                减法运算：subtract(BigInteger big)
                乘法运算：multiply(BigInteger big)
                除法运算：divide(BigInteger big)
            
            2.比较运算：
                大小比较运算：compareTo(BigInteger big)
                等值比较运算：equals(BigInteger big)
            
            3.其他运算：
                1.取最大值：max(BigInteger big)
                2.取最小值：min(BigInteger big)
                3.取绝对值：abs(BigInteger big)
            
    3.关于BigDecimal:
        1.BigDecimal的创建：
            1.通过构造方法创建：
                BigDecimal bidc = new BigDecimal();
            备注：
                1.该构造方法有多种重载形式，常用的包括以下数据类型：String，int、long、BigInteger；
                2.实际使用时，禁止使用double类型的参数，否则参数本身就已经导致数据精度不准，推荐使用String类型的参数；

            2.通过valueOf()方法创建：
                BigDecimal.valueOf();
            备注：1.valueOf支持String、long、BigInteger三种形式的参数，推荐使用String类型的参数；
                 2.此种方式以double类型为参数时和以double类型为参数的构造方法并不相同，本质上是通过String创建的，因此仍然能够保证精度准确；

        2.BigDecimal的运算：
            BigDecimal不能直接使用jdk提供的运算符号进行运算，只能使用BigDecimal类本身提供的运算方法进行运算：
            1.加减乘除运算：
                加法运算：add(BigDecimal big)
                减法运算：subtract(BigDecimal big)
                乘法运算：multiply(BigDecimal big)
                除法运算：divide(BigDecimal big)
            
            2.比较运算：
                大小比较运算：compareTo(BigInteger big)
                等值比较运算：equals(BigInteger big)
            
            3.其他运算：
                1.取最大值：max(BigInteger big)
                2.取最小值：min(BigInteger big)
                3.取绝对值：abs(BigInteger big)
        
            