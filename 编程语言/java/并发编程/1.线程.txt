1.关于进程和线程概念：
    1.进程是指一个已经启动且正在被cpu执行或者等待被cpu执行的程序，是一个程序处于运行状态的概念；
    2.在一个程序启动成为进程时，系统会为该进程分配相关的资源，比如内存空间等，因此进程是系统分配资源的最小单位；同时系统会为每一个进程分配一个id，称为进程id，简称PID；
    3.而线程则是组成进程的基本元素，一个进程由一个或者多个线程组成，反之，线程不能独立存在，必须属于某一个进程；
    4.cpu在执行程序指令时，本质上是执行进程中某一个线中的指令，因此，线程是cpu执行和调度的基本单位，一个线程运行时就会占用一个cpu核心；
    5.线程在运行时，系统并不会为线程另外分配资源，线程只能使用系统为该线程所属进程分配的资源，并且进程中的所有线程共享同一个进程的内存空间和其他资源；
    6.进程在启动时就会主动创建一个线程，称为该进程的主线程，其他线程则在主线程中创建并启动；在其他线程启动之后和主线程相比并无主次之分，本质上也并无区别，具有相同的cpu执行和调度级别；

2.线程个数的设置：(待考证)
    1.线程虽然由进程主动创建，但并非能够创建任意多个线程；线程个数的约束主要来自4个方面：
        1.系统的线程模型
        2.单个进程的虚拟内存大小
        3.实际物理内存大小；
        4.处理器的核心数量；
        5.对于java而言，堆内存大小设置；
    2.关于系统线程模型：
        1.Linux操作系统主要有两种线程模型：LinuxThreads和NPTL
            1.在lInuxThreads模型下，一个进程能够创建的线程数在1024个；该值可以配置；
            2.在NPTL模型下，单个进程内能够创建的线程数没有限制；
    3.关于单个进程的虚拟内存大小对线程个数的影响：
        1.系统需要为每一个线程分配一段地址空间，作为该线程的线程栈空间；但是一个进程的虚拟地址空间并不是无限大的，因此可用于作为线程栈的空间也将受到限制；
        2.因为进程内用来作为线程栈的地址空间有限，因此，一个进程内能够创建线程的个数也将受到限制；
        3.实际情况中，在64位操作系统下，单个进程的虚拟地址空间通常都很大，所以实际情况下，进程的虚拟地址空间大小不会成为创建线程个数的瓶颈；
    
    4.关于物理内存大小对线程个数的影响；
        
    5.关于处理器处理能力对线程个数的影响：
        1.每一个线程运行时都将占用一个处理器核心，线程数不足时将会导致处理器核心频繁切换线程；最终导致线程中真正待执行的任务并不能及时完成，反而降低了程序的执行效率；严重者表现出来的将是系统卡死；

3.Java中创建线程：
    1.通过继承Thread类来创建线程：
        1.通过继承的方式创建线程并启动线程：
            1：创建线程：
                public class SelfThread extends Thread {
                    @Override
                    public void run() {
                        // todo
                    }
                }
            2.启动线程：
                Thread thread = new Thread();
                thread.start();

        2.通过函数式接口的方式创建并线程：
            1.创建线程：
                Thread thread = new Thread() {
                    @Override
                    public void run() {
                        // todo
                    }
                }
            2.启动线程：    
                thread.start();
    2.通过继承Runable接口创建线程：
        1.通过继承的方式创建线程并启动线程：
            1：创建线程：
                public class SelfThread implements Runable {
                    @Override
                    public void run() {
                        // todo
                    }
                }
            2.启动线程：
                Thread thread = new Thread(new SelfThread());
                thread.start();

        2.通过函数式接口的方式创建并线程：
            1.创建线程：
                Thread thread = new Thread(Runable() {
                    @Override
                    public void run() {
                        // todo
                    }
                });
            2.启动线程：    
                thread.start();
    
    3.通过继承callable接口创建线程：
        1.通过继承的方式创建线程并启动线程：
            1：创建线程：
                public class SelfThread implements Callable<String> {
                    @Override
                    public String call() {
                        // todo
                    }
                }
            2.启动线程：
                Ca c1 = new Ca();
                FutureTask<String> ft1 = new FutureTask<String>(c1);
                Thread ct1 = new Thread(ft1);
                thread.start();

        2.通过函数式接口的方式创建并线程：
            1.创建线程：
                Thread thread = new Thread(new FutureTask<String>(new Callable<String>() {
                    public String call() throws Exception {
                        return null;
                    }
                }));
            2.启动线程：    
                thread.start();
        
        3.关于FutureTask：
            1.FutureTask的功能：
                1.FutureTask是连接Callable和Thread的桥梁，同时又能够通过FutureTask来获取Callable的返回值；
                2.FutureTask会以同步的方式获取Callable的返回值，即FutureTask的get方法会一直等到Callable执行完成返回结果时会才会继续向下执行；

            1.FutureTask本质：
                1.继承关系：
                    1.FutureTask是RunnableFuture接口的实现，而RunableFuture又直接继承自Runable和Future接口；
                    2.因此FutureTask既实现了Runable中执行任务的run方法，又实现了Future的获取返回值得get方法；
                2.功能原理：
                    1.FutureTask继承自Runable接口，因此FutureTask能够作为Thread构造方法的参数；
                    2.FutureTask的构造方法又以Callable类型的实例作为参数，并且在其实现Runable的run方法中调用Callable的call方法，同时得到call方法的返回值。
                    3.Future在得到call方法返回值之后，会将返回值赋值给全局属性outCome，而FutureTask同时又实现了Future接口的get方法，并在get方法中返回outCome;
                3.FutureTask使用到的设计模式：
                    1.本质上，FutureTask就是适配器模式的具体实现；通过FutureTask让Callable能够更好的适配Thread，方便以统一的方式创建线程；

    4.不同创建线程方式的区别：
        1.Runable和Thread的区别：
            1.继承方式不同：
                1.Thread是抽象类，一旦继承了Thread之后将不能在继承其他类；
                2.Runable是接口，继承Runable之后还能够继承其他类；
            2.线程类内部资源共享方式不同：
                1.在Thread实现类内部创建的共享资源，每一个Thread线程实例都将拥有一份；
                2.在Runable实现类内部创建的共享资源，所有的Runable线程实例共享同一份资源；
        2.关于Runable和Callable的区别：
            1.返回值差异：
                1.Runable类型的run方法无返回值，因此无法返回线程执行结果；
                2.Callable类型的call方法有返回值，可以返回线程执行结果；如果线程执行时间较长，那么获取执行结果的操作将会阻塞；
            2.创建方式不同：
                1.Runable实例可以直接作为Thread的参数创建线程实例；
                2.Callable实例则需要通过适配器FutureTask适配之后，才能传递给Thread创建线程实例；

4.线程的基本属性：
    1.当前正在被执行的线程：
        1.通过Thread.currentThread()方法即可获取当前正在被cpu执行的线程；
        2.该方法是一个静态方法，通常用在线程内部中，返回的是该线程对象(即Thread类的某一个实例对象)；
    2.线程id：
        1.系统为每一个线程设置了一个整数id，用来唯一标识当前进程的线程，称为线程id；
        2.当前线程的id通过线程对象调用实例方法getId()即可获取，如：Thread.currentThread.getId();
    3.线程名：
        1.线程名的设置：
            1.默认情况下，线程名会被设置为Thread-0、Thread-1这种形式；
            2.也可以在创建线程时设置线程名：new Thread("线程名")、new Thread(Runable runable,"线程名")
            3.通过线程对象调用实例方法setName("线程名")设置：Thread.currentThread.setName("线程名称")
        2.获取线程名：
            1.通过线程对象的实例方法getName()即可获取：Thread.currentThread.getName();
    4.线程优先级：
        1.设置线程的优先级：
            线程优先级默认都是5，最高可设置为10，最低可设置为1；
            setPriority(int priority);
            如：Thread.currentThread().setPriority("thread-name");
        2.获取线程的优先级：
            getProority();
            如：Thread.currentThread().getPrority();
        3.关于线程的优先级：
            1.默认情况下线程优先级相同，平等的竞争cpu时间片；
            2.手动设置线程优先级也仅仅只是对cpu调度频率有影响，并非完全线性的设置线程被执行到的频率；
            3.线程优先级具有继承特性，线程中启动的其他线程将会继承该线程的优先级；
    5.守护线程：
        1.守护线程是指运行在进程后台的线程，与之相对的是前台线程，默认情况下创建的线程均是前台线程；
        2.守护线程与前台线程本质上相同，只是进程结束与否只与前台线程相关，只要前台线程没有结束进程也不会结束，但是只要进程结束，无论守护线程是否结束，都将被终止；
        3.前台线程通常用来执行一些必须的事物，后台线程则用来执行一些可以随时被终止的非必须事物；
        4.设置为守护线程的方式：setDaemon(true)；如:Thread.currentThread().setDaemon(true);
        5.特别注意的是，后台线程必须在前台线程未调用start()方法启动之前设置，并且一旦线程转换为守护线程之后将无法转换为前台线程；

5.线程的生命周期：
    1.线程生命周期一共分为五个阶段：新建状态、就绪状态、运行状态、阻塞状态、结束状态；
    2.线程状态描述：
        1.新建状态：
            指线程对象已经创建，但暂未调用start()方法启动之前的状态；此时对于系统而言，仅仅只是一个普通的对象，并非一个线程；
        2.就绪状态：
            指线程对象调用start()方法之后，但暂未被处理器执行的状态；处于就绪状态的线程才能够被处理器执行；
        3.运行状态：
            指当前线程正在被处理器执行；此时线程的状态为运行状态；
        4.阻塞状态：
            指运行中的线程调用了Object.wait()、Thread.sleep()、Thread.join()方法之后的状态、或者线程正在等待IO方法返回的状态、或者线程正在等待锁而导致被挂起的状态；
        5.结束状态：
            线程中的指令全部运行完毕，线程执行结束的状态；

6.线程状态管理：
    1.Object类以及Thread类提供了几个线程状态管理的相关方法，具体如下：
        1.Object类：
            Object.wait()、Object.notify()、Object.notifyAll()
        2.Thread类：
            Thread.sleep()、thread.join()、Thread.yield()
    2.关于Object.wait()、Object.notify()、Object.notifyAll()方法：
        1.方法功能描述：
            1.Object.wait()通常用来阻塞线程，使线程从运行状态进入阻塞状态，并释放持有的锁；
            2.Object.notify()方法用来唤醒调用过Object.wait()而进入阻塞状态的指定线程；
            3.Object.notifyAll()方法用来唤醒所有调用过Object.wait()而进入阻塞状态的线程；
        2.使用方式和场景：
            1.上述三个方法通常需要和synchronized以及条件变量配合使用，来满足线程间需要按照一定顺序同步执行的场景；
            2.相关原理如下：
                1.通过synchronized可以实现线程间的同步执行；
                2.通过条件变量配合Object.wait()阻塞需要暂停执行的线程；
                3.通过调用Object.notify()唤醒其他线程，并通过条件变量的检测决定是否允许当前被唤醒的线程执行；
        3.关于Object.notify()和Object.notifyAll()：
            1.Object.notify()一次可以唤醒一个处于阻塞状态的线程，如果同时有多个线程处于阻塞状态时将随机唤醒一个；被唤醒的线程是否允许执行则要通过条件变量来判断；
            2.Object.notifyAll()一次可以唤醒所有处于阻塞的状态的线程；
            3.实际使用中：notifyAll()可能造成惊群效应，而notify()又可能造成死锁；
    3.关于Thread.sleep():  
        1.该方法是Thread类的静态方法，可以使线程在运行状态下直接进入阻塞状态，并且可以设置一个有效时间，在到达有效时间之后将会从新进入就绪状态，与该方法效果相同的还有TimeUnit.XXX.sleep(int sleepTime);
        2.该方法的功能只是单纯的阻塞当前线程一段时间，因此不必和synchronized配合使用，并且会响应线程的中断；
        3.该方法如果用在synchronized代码块或者synchronized方法中时并不会释放synchronized锁；
    4.关于thread.join()：
        1.该方法并非Thread类静态方法，而是需要通过Thread类实例对象调用；
        2.该方法被通过指定线程调用之后，当前线程将会进入阻塞状态，而调用该方法的线程会进入运行状态开始运行；
        3.该方法也可以设置超时时间，如果超时时间到达之后，调用该方法的线程仍然没有执行完毕时，那么被阻塞的线程也会进入就绪状态；
        
    5.Thread.yield()：
        1.该方法是Thread类的静态方法，理论上是让出当前线程的执行机会，把执行机会让给优先级和当前线程相同或者比当前线程更高的线程；
        2.但实际上该方法调用之后，线程将会重新进入就绪状态，而非进入阻塞状态，因此可能在当前线程调用完该方法之后又重新获取执行机会而进入运行状态；
7.处理线程运行中的异常：
    1.子线程虽然通过主线程启动，但是子线程启动之后将和主线程一样平等，无法通过主线程捕获子线程中的发生的异常；
    2.子线程中的异常应当在子线程的run方法中捕获并处理；


