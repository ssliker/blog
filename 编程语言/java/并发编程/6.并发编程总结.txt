1.关于并发编程和非并发编程：
    1.对于请求量低的系统，同一时刻系统只是运行在单进程、单线程的模式下，即便有多个线程通常也是执行不同的业务逻辑，只需要按照业务需求实现基本的功能逻辑接口，不需要有太复杂的实现方案；这种编程模式就是非并发编程，所以非并发编程可以应对一些请求量低的系统；
    2.对于请求量大的系统，同一时刻系统会接收到较多的请求，需要同时又多个线程、进程来处理提高系统吞吐量，这时候编程就需要考虑更复杂的实现方案，这种编程模式就叫做并发编程，所以并发编程都是为了应对流量较大的系统；
2.并发编程相比非并发编程
    相比于非并发编程而言，一般情况下以并发编程的思路来设计实现方案是需要考虑一下三个点：
        1.功能是否能够保证正确；
        2.性能是否优秀；
        3.链路是否可靠稳定；
3.功能是否正确：
    1.非并发编程中，只需要按照业务需求实现具体逻辑就可以了，只要保证业务逻辑没有错误，正确性就能得到保证；但是并发编程中，通常都是通过多线程、多进程来应对较大的流量，那么多线程、多进程就会涉及到共享资源访问的安全问题，如果共享资源无法做到同步访问就可能造成最终的业务数据不一致导致功能出错；
    2.所以并发编程下要保证功能正确除过要保证业务逻辑正确以外还需要保证线程同步访问共享资源，实际中使用的方案一般有以下几种：
        1.单机部署，单进程场景：
            1.可以使用synchronized、lock加锁实现线程同步；
            2.如果只是内存数据更新问题，也可以考虑使用Java本身的Atomic系列类实现线程同步；
            3.借助第三方组件实现加锁：
                1.借助mysql的排它锁实现悲观锁加锁机制；
                2.借助mysql+版本号实现乐观锁加锁机制；
                3.借助redis的set命令实现悲观锁加锁机制；
                4.借助redis的事务+监听机制实现乐观锁加锁机制；
                5.借助zookeeper+监听机制实现悲观锁加锁机制；
        2集群部署，多进程场景：
            1.借助mysql的排它锁实现悲观锁加锁机制；
            2.借助mysql+版本号实现乐观锁加锁机制；
            3.借助redis的set命令实现悲观锁加锁机制；
            4.借助redis的事务+监听机制实现乐观锁加锁机制；
            5.借助zookeeper+监听机制实现悲观锁加锁机制；
                
4.性能是否够好：
    1.这一点和非并发编程中的处理思路是一样的：
        1.使用缓存存储数据，加快数据的读取速度；
        2.使用队列解耦服务间的调用，加快接口返回速度；
        3.使用一些池化技术增加业务处理速度，如线程池、连接池等；
        4.能静态化的尽量静态化；
        5.无需实时处理的可以避免实时处理；
        6.水平扩展服务，结合负载均衡机制加快服务的处理速度；
        7.垂直拆分数据库，可以吧访问频率更高的数据单独部署在性能更好的机器上等；

5.链路是否稳定可靠：
    1.链路稳定可靠一般由功能上的优化也有运维上的优化：
        1.功能上：
            1.业务热点是否过于集中，是否能够将热点进行分散，将原本一步完成的操作改为多步完成，每一步都调用不同的接口；
            2.是否可以使用限流操作进行限流，防止瞬时流量过大；
            3.是否可以使用线程池、连接池获取资源，防止资源创建过多导致内存溢出；
            4.是否可以采用熔断降级机制，避免接口长时间阻塞；
    