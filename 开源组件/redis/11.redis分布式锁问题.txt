1.关于分布式锁：
    1.分布式锁通常是利用第三方组件的原子操作来实现业务服务的线程同步；
2.关于Redis实现分布式锁：
    1.Redis实现分布式锁是利用Redis的两个特点：
        1.Redis处理业务逻辑时采用的是单线程模型，同一时刻只会有一个请求被处理，借助这个特征可以实现线程间的同步；
        2.Redis中key具有唯一性，并且提供了能够返回key是否操作成功的set系列命令；
    1.实现方案1：
        1.实现方式：
            1.通过set命令+nx参数实现；
            2.通过setnx命令实现；
            说明：
                1.setnx或者set加上nx参数在设置key时会先检查key是否存在，如果存在将不再设置，返回false，否则设置key并返回true；
                2.通过这个命令才能够让多线程间竞争key的设置机会，而key只会被其中一个线程设置成功，那么设置成功的线程将获得锁；
        2.Redis实现分布式锁的常见问题：
            1.客户端崩溃，导致key无法被删除，即锁无法被释放；
                这种情况下，需要为锁加上超时时间，那么只能使用set命令+nx参数同时设置超时时间来实现，将不能再用setnx命令，setnx命令无法设置超时时间；
            2.超时时间带来的问题：
                1.如果持有锁的线程并未崩溃，只是执行时间过长，超过了超时时间，那么在当前线程未执行完成之前，锁就会被释放，进而导致其他线程获取到锁，而未执行完的线程在执行完之后又会释放锁，删除掉key，导致其他线程又获取到锁，依次类推严重者可能导致锁被连环释放；造成逻辑不再同步执行而出错；
            3.解决连环释放的问题：
                1.解决办法就是给key的值设置成线程id，那么线程在释放锁时，检查下当前持有锁的是否还是自己，不是的话就不再执行释放操作了；但是仍然无法解决可能存在多个线程同时获取到锁的问题；
                2.除过上述问题以外，删除之前需要先get后delete，但是get和delete不是原子操作，那么还是可能会出现误删的情况，这种情况需要通过lua脚本来实现；
    2.实现方案2：
        1.redis官方也提供了一套分布式锁加锁方案：RedLock：
        2.关于RedLock:
            1.RedLock核心在于少数服从多数，要求必须同时以但实例模式单独部署多个实例，(不能以集群或者主从模式部署)
            2.客户端加锁时顺序向每一个redis实例申请加锁，如果超过半数以上的实例返回加锁成功，那么当前线程就获取到锁了；
            3.具体流程如下：
                    1.顺序向五个节点请求加锁
                    2.根据一定的超时时间来推断是不是跳过该节点
                    3.超过半数节点加锁成功并且花费时间小于锁的有效期认定加锁成功
4.上述方案的具体实现工具：
    1.redsisson：
        1.redisson是redis的一个java版客户端，封装了redis操作api，同时也提供了一些高级特性，如RedssionLock可以实现分布式锁的加锁和解锁方案；
        2.第一种方案使用方式：
            使用方式非常类似于ReentrantLock：
            RedssionClient client = getClient();
            Rlock lock = client.getLock("key_name");
            lock.lock();
            ...
            lock.unlock();
        2.第二种方案使用方式：
            client.getRedLock()即可；



