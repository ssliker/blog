1.关于Redis持久化：
    1.Redis是一个基于内存的缓存数据库，而数据全部存储在内存中，如果实例崩溃、停止、系统断电之后内存中的数据将全部丢失；因此Redis提供了持久化机制，可以将数据持久化到文件中，当实例再次启动时可以重新加载数据；
    2.Redis持久化机制有两种：AOF持久化和RDB持久化；AOF是增量模式的持久化机制，RDB是全量模式的持久化机制；
2.基于RDB模式的持久化：
    1.RDB模式持久化的特点：
        1.RDB持久化是全量模式的持久化机制，每次持久化都是将内存中的数据本身以全量模式刷到磁盘上保存；
        2.由于RDB是以全量模式持久化数据，所以这种持久化机制特别适合用来进行数据的备份，实际上主从机制中主从首次同步数据就用的是rdb持久化得到的rdb文件；
        3.RDB持久化机制中记录的是数据本身，而不是像AOF一样记录key的操作命令，因此在恢复数据时，rdb文件恢复的效率更高；
    2.RDB触发方式：
        1.手动触发：
            1.客户端向服务端发送SAVE命令触发其持久化；
            2.客户端向服务端发送BGSAVE命令触发其持久化
        2.自动触发：
            1.redis配置文件中可以按照时间范围内的更新次数来配置rdb触发时机；当触发之后将会执行BGSAVE命令，配置如下：
                save 900 1 //服务器在900秒之内，对数据库执行了至少1次修改
                save 300 10 //服务器在300秒之内，对数据库执行了至少10修改
                save 60 1000 //服务器在60秒之内，对数据库执行了至少1000修改
            2.主从连接时，主服务器会执行BGSAVE命令，创建rdb文件
            3.服务端shutdown时会触发执行SAVE命令；
    3.RDB持久化执行方式：
        1.SAVE模式执行：
            1.SAVE模式下，持久化由主线程完成，效率高，但是主线程会阻塞客户端请求，直至持久化流程完毕；
            2.redis中只有手动向服务端发送SAVE命令或者服务端shutdown时才会执行SAVE命令；
        2.BGSAVE方式执行：
            1.执行BGSAVE命令时，主进程会先fork一个子进程，然后由子进程执行rdb持久化流程，主进程则继续响应客户端请求；这样的话在执行rdb持久化过程中主进程不会阻塞客户端请求，但是主进程在fork子进程期间是会阻塞客户端请求的；
            2.需要注意的是，子进程并不会把所有数据拷贝一份作为快照，而是采用的是copy-on-write技术实现主进程和子进程之间的数据共享，子进程默认会和主进程共享所有的数据，只有在主进程更新了数据之后子进程才会将被更新的数据复制一份；
        无论是SAVE还是BGSAVE，执行完成之后，内存的数据会全部在磁盘上通过rdb文件存储一份；
    4.RDB涉及到的配置：
        1.持久化自动触发时机配置：
            save 900 1 //服务器在900秒之内，对数据库执行了至少1次修改
            save 300 10 //服务器在300秒之内，对数据库执行了至少10修改
            save 60 1000 //服务器在60秒之内，对数据库执行了至少1000修改     
        2.持久化文件名称：
            dbfilename dump.rdb
        3.持久化文件目录位置：
            dir /redis/path/rdb
        4.是否压缩rdb文件：
            rdbcompression yes 
    5.BGSAVE自动触发的实现原理：
        1.在Redis中定义了一个结构体，包含两个成员：上次rdb到目前的秒数，上次rdb到目前接受到的更新命令次数：
            struct saveparam {
                time_t seconds;    // 秒数
                int changes;    // 变更次数
            }
        上述结构体用来存储redis.config中持久化的相关配置；
        2.除此之外，redis还在redisServer结构体中定义了两个字段来保存上一次rdb执行的时间、当前执行更新操作的次数；
        3.然后在redis的周期函数serverCron中根据redisServer中值和配置进行比较，检测是否需要执行rdb持久化；
    6.BGSAVE的大体实现流程：
        1.检测是否正在执行RDB持久化或者AOF持久化流程：
        1.如果有子进程正在执行RDB持久化流程，直接返回错误信息；
        2.如果正在执行AOF持久化流程，则查看是否有schedule参数：
            1.如果有该参数则将本次RDB持久化流程添加到定时事件中，等待定时事件就绪之后再执行；
            2.如果没有该参数，则直接返回错误信息；
            schedule参数的主要作用在于避免RDB和AOF冲突，造成数据的不一致；
        2.如果当前没有子进程正在执行RDB持久化也没有执行AOF持久化流程，则开始执行BGSAVE流程：
            1.备份当前脏键值(被修改的key的个数)，脏键值起着检测是否需要执行BGSAVE流程的作用，在每次执行BGSAVE完成后需要将脏键设置为0，重新计数，并且需要在当前BGSAVE流程失败之后恢复脏键的值；
            2.记录当前执行BGSAVE的时间，同样也是为了配置文件中的配置频率能够自动触发BGSAVE而设置的；
            3.开始fork子进程，如果fork成功，主进程继续响应客户端请求，子进程则开始执行SAVE流程：
                1.关闭子进程的套接字，子进程无需处理客户端请求；
                2.执行写文件操作，将内存中的数据写入rdb文件中：
                    1.创建临时文件，并以写的方式打开文件；如果打开失败则返回错误信息；
                    2.开始通过遍历的方式将所有数据库中的数据写入rdb文件；
                    3.刷新缓冲区，确保所有数据都落入磁盘；
                    4.通过cas的方式修改临时文件的名称为rdb文件名称；
    7.RDB文件格式：
        1.格式结构：|--REDIS标识(5字节)--|--redis版本号(4字节)--|--辅助信息--|--data数据--|--EOF(1字节)--|--校验和(8字节)--|
        2：RDB结构成员：
            1.RDB文件组织格式为：
                REDIS:db_version:database:EOF:check_sum
                    REDIS：
                        大写的REDIS字符串，表示该文件是Redis的RDB文件，帮助Redis快速检测文件类型；大小为5个字节；
                    db_version：
                        RDB文件版本号；大小为4个字节
                    database：
                        数据库信息，包括数据号和数据库中存储的键值对，如果数据库中无数据，该值为0；如果有数据则按照database格式存储；
                    EOF：
                        RDB文件结束符，标志RDB文件正文内容的结束，使用RDB文件恢复数据时，如果遇到该值说明所有的键值对都已经载入内存了；
                    check_sum：
                        检测RDB文件是否有错误或者损坏，该值是根据REDIS、db_version、database、EOF四个部分的内容进行计算而出的；载入RDB文件时会将载入的数据计算得到的校验值和check_sum进行对比；大小为8个字节；
                
            2.database具体数据组织格式：
                SELECTDB:db_number:key_value_pairs
                    SELECTDB：
                        数据库标识，常量，读取程序遇到该值时接下来的数据会被当做数据库号；
                    db_number：
                        具体的数据库号；
                    key_value_pairs：
                        保存该数据库中的所有的键值对；
                
            3.key_value_pairs键值对组织格式：
                EXPIRETIME_MS:ms:TYPE:key:value
                    EXPIRETIME_MS：
                        表示键值对过期时间标识，遇到该值时接下来读取到的内容会被当做过期时间，以ms为单位；长度为1字节；
                    ms：
                        具体的过期时间，8个字节大小
                    Type：
                        value的数据类型；Redis中的数据类型之一，长度为1字节：
                    Key：
                        键名
                    value：
                        键值
    8.RDB持久化方式优缺点：
        1.优点：
            1.RDB记录的是全量数据，因此非常适合进行数据备份；
            2.RDB采用子进程来执行持久化流程，执行效率较高；
            3.RDB文件中记录的是redis中所有数据的本身信息，在恢复数据时相比AOF效率更高；
        2.缺点：
            1.RDB因为是全量记录数据，并且需要fork子进程，属于重量级操作，无法做到实时或者近实时执行持久化流程；
            2.在redis或者机器挂掉之后，会丢失上次成功执行持久化之后至挂掉那一刻的所有数据；
            3.rdb是二进制文件，无法直接查看修改；
2.AOF模式持久化：
    1.关于AOF持久化：
        1.AOF持久化是以追加日志的形式记录每次更新操作命令来实现的持久化机制；
        2.可以实现实时或者近实时的持久化；
        3.AOF持久化的文件在恢复时需要按顺序执行文件中的更新命令，因此恢复效率比RDB要差一些；
    2.AOF的触发方式：
        1.AOF需要在配置文件中打开，然后配置持久化的时机即可；
    3.AOF的配置项：
        1.是否开启AOF持久化机制：
            appendonly no: 默认是no，即不开启AOF持久化机制，设置为yes即可开启；
        2.持久化自动刷盘时机配置：
            appendfsync everysec: 每秒触发一次；
            1.redis在记录写操作命令时并不会直接写入磁盘文件，而是先全部记录在内存中，然后按照配置的刷盘策略刷至磁盘文件中；
            2.redis中支持三种刷盘策略：
                1.no：何时刷盘由操作系统决定；速度快，刷盘次数少，但是可靠性最低；
                2.always：每执行一次更新命令就执行一次刷盘操作，最可靠，数据几乎不会丢失，但是性能最差；
                3.everysec：指每秒执行一次持久化，可靠性中等，性能中等，生产上常用此种方案；
            3.需要特别注意的是，配置为everysec，虽然是每秒刷盘一次，但实际一旦丢失数据将最多丢失2s的数据；
        3.aof文件名：
            appendfilename appendonly.aof  
    4.AOF持久化方式：
    1.如果在配置文件中配置appendonly为yes，那么在redis服务启动时就会以写的方式打开aof文件，并将aof文件的句柄赋值给server.aof_fd；如果在启动过程中打开aof文件失败那么服务也将启动失败；
    2.redis运行过程中如果收到写命令，那么会在call函数中执行完相关命令之后，调用propagate()函数，而在propagate()函数中会调用feedAppendOnlyFile()函数来执行AOF流程；feedAppendOnlyFile()完成两个事情：
        1.将命令格式化；
            1.先创建一个空的sds字符串，用来存储将要持久化的命令；
            2.检测当前写入aof_buf的数据库id是否是当前命令所操作的数据库id，如果不是需要在命令前面先加上SELECT db命令，保证在恢复数据时能够将数据恢复至正确的数据库；
            3.转换命令中的有效期格式：
                1.如果当前命令仅为设置过期时间，则将相对时间转换为绝对时间；
                2.如果当前命令在设置键值的同时设置有效期，则先拆分命令为设置键值命令和设置有效期命令，然后将有效期时间转换为绝对时间；
            4.对转换之后的命令格式化成指定格式的字符串，并追加至第一步执行完成后的字符串后(如果有的话)；
        2.将格式化之后的命令追加至aof_buf中；
            将第一步格式化之后的字符串添加至aof_buf缓冲区中；如果此时正在进行aof_rewrite操作，那么也会将该命令追加至aof_rewrite_buf中；
    3.同步磁盘文件：
        由于aof持久化方式直接操作文件本身，属于重量级操作，如果每次直接将命令追加至文件中，效率会比较低；因此redis会先将待追加命令写入缓存中，然后按照配置文件中配置的appendfsync everysec来择机将缓存刷入磁盘；具体流程如下：
        1.为了防止在数据回复客户端之后数据出现不一致，因此在回复客户端修改结果之前需要先将aof_buf按照策略刷盘持久化，而回复客户端之前需要先在事件循环中进入休眠，一旦进入休眠，那么客户端的写事件就会就绪，就需要向客户端回复响应；因此aof_buf刷盘的唯一机会就在进入休眠之前，而redis会在进入休眠之前调用beforeSleep()函数完成休眠之前的善后工作，因此redis会在该函数中调用flushAppendOnlyFile(0)函数来完成刷盘操作；
        2.flushAppendOnlyFile(0)函数接收一个参数，该参数(force)表示是否强制执行刷盘操作，之所以要有该参数是因为，在输盘策略配置为1时，在reids后台可能会有子线程正在执行fsync操作，如果有线程正在执行fsync操作时那么write可能会发生阻塞，因此需要将本次刷盘的flush操作延迟执行；如果force参数设置为1，那么redis将会无视后台的fsync，直接执行写入操作；
        3.flushAppendOnlyFile(0)将按照以下流程执行持久化：
            1.检测aof_buf中是否有待持久化数据，如果没有则直接返回；
            2.如果同步策略是每秒执行一次，那么会先检测当前后台是否有线程正在执行之前的aof操作；因为有可能aof操作时间较久，导致上次的aof操作还未完成；
            3.如果同步策略是每秒执行一次，并且不是强制执行，同时还有后台线程正在执行之前的aof操作；则继续判断在本次aof刷盘之前还有更早的延迟操作；
                1.如果没有，则表示当前aof操作之前没有等到被刷盘的操作，然后将当前时间保存下来作为当前操作的延迟开始时间，直接返回；
                2.如果在当前aof操作之前已经有上一次的aof操作还未执行而且正在等待执行，并且等待时间没有超过2s，那么直接返回，不执行write，将本次刷盘操作和正在等待延迟刷盘操作合并执行；
                3.如果在本次aof操作之前，已有等待执行刷盘的aof操作并且等待时间超过2s；则直接执行write操作刷盘；并将延迟时间恢复为0；
                4.检测写入是否出错，即写入文件的字节数如果不等于缓存的字节数则发生异常：
                    1.如果写入策略为每次执行写操作之后都需要写入文件：那么直接终止程序；
                    2.如果写入策略为每秒一次：
                        1.如果写入错误，则直接记录错误日志，并返回；
                        2.如果只写入了部分数据，则将本次给文件中追加的内容截断，删掉已经追加的内容，然后返回；
                        3.如果无法截断已经写入的aof文件，则将aof_buf进行截断，只留未写入文件的部分缓存；
                5.如果写入未出错，则更新写入状态以及aof文件大小；检测是否需要重用当前缓存；如果当前aof_buf小于4k，则直接将缓存内容清空，然后继续重用缓存；否则释放掉这个大内存，然后重新申请一个更小的内存空间；
            4.写入成功之后需要调用fsync刷新系统缓冲区，如果正在执行BGSAVE或者正在执行BGREWRITE，那么不执行本次fsync操作；如果持久化策略为always，那么调用fsync刷新系统缓冲区，如果刷新策略是EVERYSEC，并且当前时间大于上次执行同步的时间，而且当前没有正在执行同步的线程，那么在后台开一个线程执行同步；
        5.AOF重写机制：
            1.重写原因：
                由于aof是追加的方式向一个独立的文件中写入操作命令，如果redis在运行比较久之后可能该aof文件体积会比较大，为了解决这个问题，redis引入了重写机制来压缩文件的体积； 
            
            2.重写方式：
                1.进程中已经delete的数据不再保留命令；
                2.进程中还存在的数据直接保存一个set命令即可；
            
            3.触发机制：
                1.手动触发：手动向服务端发送BGREWRITEAOF命令；
                2.自动触发：根据redis.conf配置IDE两个参数确定触发时机：
                    1.auto-aof-rewrite-percentage 100：当前AOF文件的大小和上一次重写后AOF文件的大小比值超过该值，将会触发重写；
                    2.auto-aof-rewrite-min-size 64mb：进行AOF文件重写时文件最小的体积，只要超过该体积就会触发重写；
            
            4.重写流程：
                1.AOF重写时可能会耗费较长时间，因此会fork一个子进程在后台进行重写，然后父进程会继续响应客户端请求；
                2.子进程在重写期间，由于主进程还在响应客户端请求，因此可能会导致数据库状态和AOF重写之后保存的状态不一致；为了解决这个问题，redis提供了一个重写缓冲区来保存子进程重写期间，主进程执行过的命令：
                    // AOF块缓冲区结构
                    typedef struct aofrwblock {
                        // 当前已经使用的和可用的字节数
                        unsigned long used, free;
                        // 缓冲区
                        char buf[AOF_RW_BUF_BLOCK_SIZE];
                    } aofrwblock;
                    重写缓冲区并非一个大块的内存空间，而是由10MB大小的节点组成的一个链表；
                3.在重写期间，主进程响应客户端请求时安装以下流程进行：
                    1.执行客户端命令
                    2.将指向后的命令追加到AOF缓冲区中；
                    3.将执行后的写命令追加到AOF重写缓冲区中；
                
                4.重写细节：
                    1.在触发BGREWRITEAOF命令之后，主进程调用rewriteAppendOnlyFileBackground函数，执行重写流程：
                        1.检测当前是否正在进行重写，如果正在进行重写或者正在进行RDB持久化则返回错误信息；
                        2.fork一个子进程，并创建父子进程的通信管道；
                            1.子进程无需响应客户端请求，因此子进程中首先关闭监听套接字；
                            2.创建临时文件，用来存储重写之后的AOF文件内容；
                            3.遍历数据库，将仍然有效的键值对数据以set命令的方式写入临时文件中；
                            4.从主进程中读取差异数据，然后更新至临时文件中；如果持续20ms读取不到数据，那么子进程终止读取数据；   
                            5.重写完成之后，CAS方式将临时文件名称改为aof文件名；

