1.关于redis缓存淘汰：
    redis在内存中记录所存储的数据，在内存不足时，将会按照预先配置的缓存淘汰策略淘汰一部分缓存数据，腾出空间存储新的数据；

2.缓存淘汰触发时机：
    1.如果配置了maxmemory：
	1.redis中所有的内存消耗量加起来不能超过该值；就会触发缓存淘汰流程；默认大小是4G；
	2.64位系统下，如果该值默认为0，表示不限制redis使用的内存大小，最大为系统物理内存，32位系统下，该值默认为3G；
    2.该值对redis使用的影响：
	1.如果配置了该值，而redis使用内存的大小超过了该值，那么将会触发缓存淘汰策略，置换出内存空间；
	2.生产环境如果内存占用量超过该值的配置时，可以选择手动删除部分key，也可以选择通过config set maxmemory 100G来提高该限制；
	3.如果超过该值，且无法置换出空闲内存空间，但是系统内存还有空间，那么进程不会挂掉，查询操作还可以继续执行，但是新增和更新操作将会报错；
	4.如果未设置该值，导致redis可使用内存空间是整个系统物理内存，而且占满物理内存时进程会被系统kill掉，缓存服务彻底失效，所以实际使用中一定要配置这个配置；
	
3.缓存淘汰策略：
    1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键中选择空转时间最长的键值对清除掉；

    2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间内使用频次最小的键值对清除掉；数据清理更精确，REDIS4.0以上提供

    3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；

    4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；

    5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；

    6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；
你      
    7.allkeys-random:所有的键中，随机选择键进行删除；

    8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;
    备注：volatile:是指在过期的键中执行策略；
         allkeys:是指在所有的键中执行策略；
         noeviction:默认策略；

4.缓存淘汰策略的选择：
    1.如果缓存数据有明显的冷热区分时，建议使用volatile-lru或者allkeys-lfu；
    2.如果key的有效性和时间相关，时间越久有效性月底，则建议使用volatile-ttl；
    3.如果缓存数据没有明显冷热区分，且访问量都不高，推荐使用volatile-random或者allkeys-random；
    4.如果缓存中的数据没有过期时间，并且需要保全所有数据本身，则需要配置为noeviction；

5.关于缓存淘汰样本：
    1.由于redis淘汰缓存时使用工作线程执行淘汰流程，那么在淘汰缓存期间将会阻塞，不再应答客户端请求；为了避免长时间阻塞客户端请求，redis服务端通过每次选择一小批key，然后在这一小批key里面按照淘汰算法淘汰数据，完成之后如果每次淘汰的数据占总样本的25%，那么继续执行淘汰流程；每次选择的样本数量由maxmemory-samples 来控制，默认是20个；
    2.为了防止在一小批key里面淘汰数据时发生阻塞，redis还设置了超时时间，默认是25ms，即超过25ms无论淘汰流程是否执行完成，都将结束本次淘汰流程；
    3.redis实际使用的内存空间实际上可能会超过maxmemory的大小，因为缓存淘汰流程预释放的目标内存空间大小就是实际已用大小-maxmemory的大小；

6.redis缓存使用配置：
    1.最大内存使用量：
        1.配置文件配置：maxmemory 100mb
        2.命令配置：config set maxmemory 100mb
        3.如果该值配置为0或者不配置：
            对于32位系统最大可使用内容3GB(跟虚拟内存限制有关，一个进程最多能够使用的虚拟内存大小是4GB，预留1GB给服务，3GB来存储数据)；
            对于64位系统下则和物理内存大小有关，能够使用的最大内存理论上是整个物理内存；
    2.淘汰策略：
        1.maxmomery-policy设置
    
    3.每次淘汰样本大小：
        1.maxmomery-simples设置

7.关于过期key的删除的时机：
    1.对于过期key的删除策略：
        1.惰性删除：
            对于主节点：在客户端访问该key时，检查该key是否已经过期，如果已经过期则删除对应的key；
            对于从节点：即便检测到key已经过期，也不会删除该key，此时从节点将不做任何处理，从节点只有收到主节点的del命令时才会删除key；
        2.定期部分删除；
            定期删除是在serverCron函数中执行的，该函数会被注册为定时事件，类似io事件，10s触发一次，每次触发都会执行淘汰流程；每次删除时遍历整个db，选取一定的样本key，然后从样本key中删除数据，如果本次删除数量超过样本总数的25%则继续执行删除流程；如果执行时间超过阈值时间(默认25ms)则直接退出；

    2.持久化过程中过期key的删除：
        1.对于RDB：1.在写入RDB文件时会对键的过期时间检查，如果过期将不会写入RDB文件；
                   2.在恢复RDB文件时，也会对RDB文件中的键检查：
                        1.对于主服务器，会直接删掉已经过期的key；
                        2.对于从服务器则会全部加载至内存中，但是在从服务器和主服务器同步数据之前会先将从服务器数据全部删除，因此从服务器中的过期数据也将被删除；
        2.对于AOF：1.如果key已经过期，在清理完该key之后，服务端会向AOF文件写入一条del指令，表示该key已经删除；
                  2.在执行重写过程中，会检测该key是否已经过期，如果已经过期将不会被保存到重写之后的AOF文件中；
    
    3.主从复制过程中key的删除：
        1.对于主从复制：主服务器在删除一个过期的key之后，会向所有从节点发送一条del指令，将key从从节点中删除；

8.redis中过期删除的实现方式：
    1.redis-db结构体：
        typedef struct redisDb {
            dict *dict;     /* 键空间 key space */
            dict *expires;    /* 过期字典 */
            dict *blocking_keys;  /* Keys with clients waiting for data (BLPOP) */
            dict *ready_keys;   /* Blocked keys that received a PUSH */
            dict *watched_keys;   /* WATCHED keys for MULTI/EXEC CAS */
            struct evictionPoolEntry *eviction_pool; /* Eviction pool of keys */
            int id;      /* Database ID */
            long long avg_ttl;   /* Average TTL, just for stats */
        } redisDb;
    
        redis中每一个数据库都对应该结构体，数据库中的数据存储在该结构体中的dict中，除此之外，redis还会将设置了过期时间的key以及其过期时间存储在expires这个过期字典中；